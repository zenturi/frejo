// Generated by Haxe 4.0.0-preview.4+1e3e5e0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_ValueType
#include <ValueType.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_BalancedTree
#include <haxe/ds/BalancedTree.h>
#endif
#ifndef INCLUDED_haxe_ds_EnumValueMap
#include <haxe/ds/EnumValueMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_minject_Injector
#include <minject/Injector.h>
#endif
#ifndef INCLUDED_mmvc_api_ICommand
#include <mmvc/api/ICommand.h>
#endif
#ifndef INCLUDED_mmvc_api_ITriggerMap
#include <mmvc/api/ITriggerMap.h>
#endif
#ifndef INCLUDED_mmvc_base_TriggerMap
#include <mmvc/base/TriggerMap.h>
#endif
#ifndef INCLUDED_mmvc_impl_TriggerCommand
#include <mmvc/impl/TriggerCommand.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_80643b951edd4de2_47_new,"mmvc.base.TriggerMap","new",0xd01016b2,"mmvc.base.TriggerMap.new","mmvc/base/TriggerMap.hx",47,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_51_map,"mmvc.base.TriggerMap","map",0xd00f50ee,"mmvc.base.TriggerMap.map","mmvc/base/TriggerMap.hx",51,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_64_unmap,"mmvc.base.TriggerMap","unmap",0x130260b5,"mmvc.base.TriggerMap.unmap","mmvc/base/TriggerMap.hx",64,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_77_dispatch,"mmvc.base.TriggerMap","dispatch",0x89ad5f28,"mmvc.base.TriggerMap.dispatch","mmvc/base/TriggerMap.hx",77,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_90_mapClass,"mmvc.base.TriggerMap","mapClass",0x2ae4786a,"mmvc.base.TriggerMap.mapClass","mmvc/base/TriggerMap.hx",90,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_99_unmapClass,"mmvc.base.TriggerMap","unmapClass",0x427fd743,"mmvc.base.TriggerMap.unmapClass","mmvc/base/TriggerMap.hx",99,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_109_dispatchClass,"mmvc.base.TriggerMap","dispatchClass",0x044697f0,"mmvc.base.TriggerMap.dispatchClass","mmvc/base/TriggerMap.hx",109,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_121_mapString,"mmvc.base.TriggerMap","mapString",0x6924545f,"mmvc.base.TriggerMap.mapString","mmvc/base/TriggerMap.hx",121,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_129_unmapString,"mmvc.base.TriggerMap","unmapString",0xf97bf366,"mmvc.base.TriggerMap.unmapString","mmvc/base/TriggerMap.hx",129,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_138_dispatchString,"mmvc.base.TriggerMap","dispatchString",0xc59dca19,"mmvc.base.TriggerMap.dispatchString","mmvc/base/TriggerMap.hx",138,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_148_mapEnumValue,"mmvc.base.TriggerMap","mapEnumValue",0x0a9c01e2,"mmvc.base.TriggerMap.mapEnumValue","mmvc/base/TriggerMap.hx",148,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_156_unmapEnumValue,"mmvc.base.TriggerMap","unmapEnumValue",0x2832413b,"mmvc.base.TriggerMap.unmapEnumValue","mmvc/base/TriggerMap.hx",156,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_165_dispatchEnumValue,"mmvc.base.TriggerMap","dispatchEnumValue",0xd0ab5c68,"mmvc.base.TriggerMap.dispatchEnumValue","mmvc/base/TriggerMap.hx",165,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_176_mapInt,"mmvc.base.TriggerMap","mapInt",0xe1eb3ca1,"mmvc.base.TriggerMap.mapInt","mmvc/base/TriggerMap.hx",176,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_184_unmapInt,"mmvc.base.TriggerMap","unmapInt",0x2695033a,"mmvc.base.TriggerMap.unmapInt","mmvc/base/TriggerMap.hx",184,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_193_dispatchInt,"mmvc.base.TriggerMap","dispatchInt",0xe6604ea7,"mmvc.base.TriggerMap.dispatchInt","mmvc/base/TriggerMap.hx",193,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_204_mapInstance,"mmvc.base.TriggerMap","mapInstance",0xb7e1caa3,"mmvc.base.TriggerMap.mapInstance","mmvc/base/TriggerMap.hx",204,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_214_unmapInstance,"mmvc.base.TriggerMap","unmapInstance",0xc4a4796a,"mmvc.base.TriggerMap.unmapInstance","mmvc/base/TriggerMap.hx",214,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_225_dispatchInstance,"mmvc.base.TriggerMap","dispatchInstance",0x3defa2dd,"mmvc.base.TriggerMap.dispatchInstance","mmvc/base/TriggerMap.hx",225,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_238_invokeCommand,"mmvc.base.TriggerMap","invokeCommand",0x18dea185,"mmvc.base.TriggerMap.invokeCommand","mmvc/base/TriggerMap.hx",238,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_253_isClass,"mmvc.base.TriggerMap","isClass",0x8610f340,"mmvc.base.TriggerMap.isClass","mmvc/base/TriggerMap.hx",253,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_258_isString,"mmvc.base.TriggerMap","isString",0xd4e354c9,"mmvc.base.TriggerMap.isString","mmvc/base/TriggerMap.hx",258,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_263_isEnumValue,"mmvc.base.TriggerMap","isEnumValue",0x864d9fb8,"mmvc.base.TriggerMap.isEnumValue","mmvc/base/TriggerMap.hx",263,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_268_isInt,"mmvc.base.TriggerMap","isInt",0x2d6635f7,"mmvc.base.TriggerMap.isInt","mmvc/base/TriggerMap.hx",268,0x045b2c9e)
HX_LOCAL_STACK_FRAME(_hx_pos_80643b951edd4de2_273_isClassInstance,"mmvc.base.TriggerMap","isClassInstance",0x2ca90ef5,"mmvc.base.TriggerMap.isClassInstance","mmvc/base/TriggerMap.hx",273,0x045b2c9e)
namespace mmvc{
namespace base{

void TriggerMap_obj::__construct( ::minject::Injector injector){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_47_new)
HXDLIN(  47)		this->injector = injector;
            	}

Dynamic TriggerMap_obj::__CreateEmpty() { return new TriggerMap_obj; }

void *TriggerMap_obj::_hx_vtable = 0;

Dynamic TriggerMap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TriggerMap_obj > _hx_result = new TriggerMap_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool TriggerMap_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1213df6e;
}

static ::mmvc::api::ITriggerMap_obj _hx_mmvc_base_TriggerMap__hx_mmvc_api_ITriggerMap= {
	( void (hx::Object::*)( ::Dynamic,hx::Class))&::mmvc::base::TriggerMap_obj::map,
	( void (hx::Object::*)( ::Dynamic,hx::Class))&::mmvc::base::TriggerMap_obj::unmap,
	( void (hx::Object::*)( ::Dynamic))&::mmvc::base::TriggerMap_obj::dispatch,
};

void *TriggerMap_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x050cc2e0: return &_hx_mmvc_base_TriggerMap__hx_mmvc_api_ITriggerMap;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void TriggerMap_obj::map( ::Dynamic trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_51_map)
HXLINE(  52)		if (this->isClass(trigger)) {
HXLINE(  53)			this->mapClass(trigger,command);
HXDLIN(  53)			return;
            		}
HXLINE(  54)		if (this->isString(trigger)) {
HXLINE(  55)			this->mapString(( (::String)(trigger) ),command);
HXDLIN(  55)			return;
            		}
HXLINE(  56)		if (this->isEnumValue(trigger)) {
HXLINE(  57)			this->mapEnumValue(trigger,command);
HXDLIN(  57)			return;
            		}
HXLINE(  58)		if (this->isInt(trigger)) {
HXLINE(  59)			this->mapInt(( (int)(trigger) ),command);
HXDLIN(  59)			return;
            		}
HXLINE(  60)		HX_STACK_DO_THROW(((HX_("Mapping type ",74,85,5c,20) + ::Std_obj::string(::Type_obj::_hx_typeof(trigger))) + HX_(" is not supported.",83,63,94,3b)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,map,(void))

void TriggerMap_obj::unmap( ::Dynamic trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_64_unmap)
HXLINE(  65)		if (this->isClass(trigger)) {
HXLINE(  66)			this->unmapClass(trigger,command);
HXDLIN(  66)			return;
            		}
HXLINE(  67)		if (this->isString(trigger)) {
HXLINE(  68)			this->unmapString(( (::String)(trigger) ),command);
HXDLIN(  68)			return;
            		}
HXLINE(  69)		if (this->isEnumValue(trigger)) {
HXLINE(  70)			this->unmapEnumValue(trigger,command);
HXDLIN(  70)			return;
            		}
HXLINE(  71)		if (this->isInt(trigger)) {
HXLINE(  72)			this->unmapInt(( (int)(trigger) ),command);
HXDLIN(  72)			return;
            		}
HXLINE(  73)		HX_STACK_DO_THROW(((HX_("Unmapping type ",7b,13,72,f6) + ::Std_obj::string(::Type_obj::_hx_typeof(trigger))) + HX_(" is not supported.",83,63,94,3b)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmap,(void))

void TriggerMap_obj::dispatch( ::Dynamic trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_77_dispatch)
HXLINE(  78)		if (this->isEnumValue(trigger)) {
HXLINE(  79)			this->dispatchEnumValue(trigger);
HXDLIN(  79)			return;
            		}
HXLINE(  80)		if (this->isString(trigger)) {
HXLINE(  81)			this->dispatchString(( (::String)(trigger) ));
HXDLIN(  81)			return;
            		}
HXLINE(  82)		if (this->isInt(trigger)) {
HXLINE(  83)			this->dispatchInt(( (int)(trigger) ));
HXDLIN(  83)			return;
            		}
HXLINE(  84)		if (this->isClassInstance(trigger)) {
HXLINE(  85)			this->dispatchClass(trigger);
HXDLIN(  85)			return;
            		}
HXLINE(  86)		HX_STACK_DO_THROW(((HX_("Unmapping type ",7b,13,72,f6) + ::Std_obj::string(::Type_obj::_hx_typeof(trigger))) + HX_(" is not supported.",83,63,94,3b)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatch,(void))

void TriggerMap_obj::mapClass(hx::Class trigger,hx::Class command){
            	HX_GC_STACKFRAME(&_hx_pos_80643b951edd4de2_90_mapClass)
HXLINE(  91)		if (hx::IsNull( this->classToCommand )) {
HXLINE(  92)			this->classToCommand =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            		}
HXLINE(  93)		::String key = ::Type_obj::getClassName(trigger);
HXLINE(  94)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->classToCommand->get(key)) );
HXLINE(  95)		if (hx::IsNull( list )) {
HXLINE(  95)			this->classToCommand->set(key,::Array_obj< ::Dynamic>::__new(1)->init(0,command));
            		}
            		else {
HXLINE(  95)			list->push(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,mapClass,(void))

void TriggerMap_obj::unmapClass(hx::Class trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_99_unmapClass)
HXLINE( 100)		if (hx::IsNull( this->classToCommand )) {
HXLINE( 101)			return;
            		}
HXLINE( 102)		::String key = ::Type_obj::getClassName(trigger);
HXLINE( 103)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->classToCommand->get(key)) );
HXLINE( 104)		if (hx::IsNotNull( list )) {
HXLINE( 105)			list->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmapClass,(void))

void TriggerMap_obj::dispatchClass( ::Dynamic trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_109_dispatchClass)
HXLINE( 110)		if (hx::IsNull( this->classToCommand )) {
HXLINE( 111)			return;
            		}
HXLINE( 112)		hx::Class triggerClass = ::Type_obj::getClass(trigger);
HXLINE( 113)		::String key = ::Type_obj::getClassName(triggerClass);
HXLINE( 114)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->classToCommand->get(key)) );
HXLINE( 115)		if (hx::IsNotNull( list )) {
HXLINE( 116)			int _g = 0;
HXDLIN( 116)			while((_g < list->length)){
HXLINE( 116)				hx::Class commandClass = list->__get(_g).StaticCast< hx::Class >();
HXDLIN( 116)				_g = (_g + 1);
HXLINE( 117)				this->invokeCommand(trigger,triggerClass,commandClass);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatchClass,(void))

void TriggerMap_obj::mapString(::String trigger,hx::Class command){
            	HX_GC_STACKFRAME(&_hx_pos_80643b951edd4de2_121_mapString)
HXLINE( 122)		if (hx::IsNull( this->stringToCommand )) {
HXLINE( 123)			this->stringToCommand =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            		}
HXLINE( 124)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->stringToCommand->get(trigger)) );
HXLINE( 125)		if (hx::IsNull( list )) {
HXLINE( 125)			this->stringToCommand->set(trigger,::Array_obj< ::Dynamic>::__new(1)->init(0,command));
            		}
            		else {
HXLINE( 125)			list->push(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,mapString,(void))

void TriggerMap_obj::unmapString(::String trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_129_unmapString)
HXLINE( 130)		if (hx::IsNull( this->stringToCommand )) {
HXLINE( 131)			return;
            		}
HXLINE( 132)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->stringToCommand->get(trigger)) );
HXLINE( 133)		if (hx::IsNotNull( list )) {
HXLINE( 134)			list->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmapString,(void))

void TriggerMap_obj::dispatchString(::String trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_138_dispatchString)
HXLINE( 139)		if (hx::IsNull( this->stringToCommand )) {
HXLINE( 140)			return;
            		}
HXLINE( 141)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->stringToCommand->get(trigger)) );
HXLINE( 142)		if (hx::IsNotNull( list )) {
HXLINE( 143)			int _g = 0;
HXDLIN( 143)			while((_g < list->length)){
HXLINE( 143)				hx::Class commandClass = list->__get(_g).StaticCast< hx::Class >();
HXDLIN( 143)				_g = (_g + 1);
HXLINE( 144)				this->invokeCommand(trigger,hx::ClassOf< ::String >(),commandClass);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatchString,(void))

void TriggerMap_obj::mapEnumValue( ::Dynamic trigger,hx::Class command){
            	HX_GC_STACKFRAME(&_hx_pos_80643b951edd4de2_148_mapEnumValue)
HXLINE( 149)		if (hx::IsNull( this->enumValueToCommand )) {
HXLINE( 150)			this->enumValueToCommand =  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX );
            		}
HXLINE( 151)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->enumValueToCommand->get(trigger)) );
HXLINE( 152)		if (hx::IsNull( list )) {
HXLINE( 152)			this->enumValueToCommand->set(trigger,::Array_obj< ::Dynamic>::__new(1)->init(0,command));
            		}
            		else {
HXLINE( 152)			list->push(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,mapEnumValue,(void))

void TriggerMap_obj::unmapEnumValue( ::Dynamic trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_156_unmapEnumValue)
HXLINE( 157)		if (hx::IsNull( this->enumValueToCommand )) {
HXLINE( 158)			return;
            		}
HXLINE( 159)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->enumValueToCommand->get(trigger)) );
HXLINE( 160)		if (hx::IsNotNull( list )) {
HXLINE( 161)			list->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmapEnumValue,(void))

void TriggerMap_obj::dispatchEnumValue( ::Dynamic trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_165_dispatchEnumValue)
HXLINE( 166)		if (hx::IsNull( this->enumValueToCommand )) {
HXLINE( 167)			return;
            		}
HXLINE( 168)		hx::Class triggerClass = ::Type_obj::getClass(trigger);
HXLINE( 169)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->enumValueToCommand->get(trigger)) );
HXLINE( 170)		if (hx::IsNotNull( list )) {
HXLINE( 171)			int _g = 0;
HXDLIN( 171)			while((_g < list->length)){
HXLINE( 171)				hx::Class commandClass = list->__get(_g).StaticCast< hx::Class >();
HXDLIN( 171)				_g = (_g + 1);
HXLINE( 172)				this->invokeCommand(trigger,triggerClass,commandClass);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatchEnumValue,(void))

void TriggerMap_obj::mapInt(int trigger,hx::Class command){
            	HX_GC_STACKFRAME(&_hx_pos_80643b951edd4de2_176_mapInt)
HXLINE( 177)		if (hx::IsNull( this->intToCommand )) {
HXLINE( 178)			this->intToCommand =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            		}
HXLINE( 179)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->intToCommand->get(trigger)) );
HXLINE( 180)		if (hx::IsNull( list )) {
HXLINE( 180)			this->intToCommand->set(trigger,::Array_obj< ::Dynamic>::__new(1)->init(0,command));
            		}
            		else {
HXLINE( 180)			list->push(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,mapInt,(void))

void TriggerMap_obj::unmapInt(int trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_184_unmapInt)
HXLINE( 185)		if (hx::IsNull( this->intToCommand )) {
HXLINE( 186)			return;
            		}
HXLINE( 187)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->intToCommand->get(trigger)) );
HXLINE( 188)		if (hx::IsNotNull( list )) {
HXLINE( 189)			list->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmapInt,(void))

void TriggerMap_obj::dispatchInt(int trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_193_dispatchInt)
HXLINE( 194)		if (hx::IsNull( this->intToCommand )) {
HXLINE( 195)			return;
            		}
HXLINE( 196)		hx::Class triggerClass = ::Type_obj::getClass(trigger);
HXLINE( 197)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->intToCommand->get(trigger)) );
HXLINE( 198)		if (hx::IsNotNull( list )) {
HXLINE( 199)			int _g = 0;
HXDLIN( 199)			while((_g < list->length)){
HXLINE( 199)				hx::Class commandClass = list->__get(_g).StaticCast< hx::Class >();
HXDLIN( 199)				_g = (_g + 1);
HXLINE( 200)				this->invokeCommand(trigger,triggerClass,commandClass);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatchInt,(void))

void TriggerMap_obj::mapInstance( ::Dynamic trigger,hx::Class command){
            	HX_GC_STACKFRAME(&_hx_pos_80643b951edd4de2_204_mapInstance)
HXLINE( 205)		if (!(this->isClassInstance(trigger))) {
HXLINE( 206)			HX_STACK_DO_THROW(((HX_("Trigger ",08,f8,3c,d7) + ::Std_obj::string(trigger)) + HX_(" is not an object.",9f,f7,a0,10)));
            		}
HXLINE( 207)		if (hx::IsNull( this->instanceToCommand )) {
HXLINE( 208)			this->instanceToCommand =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            		}
HXLINE( 209)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->instanceToCommand->get(trigger)) );
HXLINE( 210)		if (hx::IsNull( list )) {
HXLINE( 210)			this->instanceToCommand->set(trigger,::Array_obj< ::Dynamic>::__new(1)->init(0,command));
            		}
            		else {
HXLINE( 210)			list->push(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,mapInstance,(void))

void TriggerMap_obj::unmapInstance( ::Dynamic trigger,hx::Class command){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_214_unmapInstance)
HXLINE( 215)		if (!(this->isClassInstance(trigger))) {
HXLINE( 216)			HX_STACK_DO_THROW(((HX_("Trigger ",08,f8,3c,d7) + ::Std_obj::string(trigger)) + HX_(" is not an object.",9f,f7,a0,10)));
            		}
HXLINE( 217)		if (hx::IsNull( this->instanceToCommand )) {
HXLINE( 218)			return;
            		}
HXLINE( 219)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->instanceToCommand->get(trigger)) );
HXLINE( 220)		if (hx::IsNotNull( list )) {
HXLINE( 221)			list->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(TriggerMap_obj,unmapInstance,(void))

void TriggerMap_obj::dispatchInstance( ::Dynamic trigger){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_225_dispatchInstance)
HXLINE( 226)		if (!(this->isClassInstance(trigger))) {
HXLINE( 227)			HX_STACK_DO_THROW(((HX_("Trigger ",08,f8,3c,d7) + ::Std_obj::string(trigger)) + HX_(" is not an object.",9f,f7,a0,10)));
            		}
HXLINE( 228)		if (hx::IsNull( this->instanceToCommand )) {
HXLINE( 229)			return;
            		}
HXLINE( 230)		hx::Class triggerClass = ::Type_obj::getClass(trigger);
HXLINE( 231)		::Array< ::Dynamic> list = ( (::Array< ::Dynamic>)(this->instanceToCommand->get(trigger)) );
HXLINE( 232)		if (hx::IsNotNull( list )) {
HXLINE( 233)			int _g = 0;
HXDLIN( 233)			while((_g < list->length)){
HXLINE( 233)				hx::Class commandClass = list->__get(_g).StaticCast< hx::Class >();
HXDLIN( 233)				_g = (_g + 1);
HXLINE( 234)				this->invokeCommand(trigger,triggerClass,commandClass);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,dispatchInstance,(void))

void TriggerMap_obj::invokeCommand( ::Dynamic trigger,hx::Class triggerClass,hx::Class commandClass){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_238_invokeCommand)
HXLINE( 239)		if (hx::IsNull( commandClass )) {
HXLINE( 240)			return;
            		}
HXLINE( 242)		::Dynamic command = this->injector->instantiate(commandClass);
HXLINE( 243)		if (::Std_obj::is(command,hx::ClassOf< ::mmvc::impl::TriggerCommand >())) {
HXLINE( 245)			 ::mmvc::impl::TriggerCommand triggerCommand = ( ( ::mmvc::impl::TriggerCommand)(command) );
HXLINE( 246)			triggerCommand->trigger = trigger;
            		}
HXLINE( 248)		::mmvc::api::ICommand_obj::execute(command);
            	}


HX_DEFINE_DYNAMIC_FUNC3(TriggerMap_obj,invokeCommand,(void))

bool TriggerMap_obj::isClass( ::Dynamic source){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_253_isClass)
HXDLIN( 253)		return ::Std_obj::is(source,hx::ClassOf< ::hx::Class >());
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,isClass,return )

bool TriggerMap_obj::isString( ::Dynamic source){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_258_isString)
HXDLIN( 258)		return ::Std_obj::is(source,hx::ClassOf< ::String >());
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,isString,return )

bool TriggerMap_obj::isEnumValue( ::Dynamic source){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_263_isEnumValue)
HXDLIN( 263)		return ::Reflect_obj::isEnumValue(source);
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,isEnumValue,return )

bool TriggerMap_obj::isInt( ::Dynamic source){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_268_isInt)
HXDLIN( 268)		return ::Std_obj::is(source,hx::ClassOf< int >());
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,isInt,return )

bool TriggerMap_obj::isClassInstance( ::Dynamic source){
            	HX_STACKFRAME(&_hx_pos_80643b951edd4de2_273_isClassInstance)
HXDLIN( 273)		bool _hx_tmp;
HXDLIN( 273)		bool _hx_tmp1;
HXDLIN( 273)		if (hx::IsNotNull( ::Type_obj::getClass(source) )) {
HXDLIN( 273)			_hx_tmp1 = ::Math_obj::isNaN(( (Float)(source) ));
            		}
            		else {
HXDLIN( 273)			_hx_tmp1 = false;
            		}
HXDLIN( 273)		if (_hx_tmp1) {
HXDLIN( 273)			_hx_tmp = !(this->isString(source));
            		}
            		else {
HXDLIN( 273)			_hx_tmp = false;
            		}
HXDLIN( 273)		if (_hx_tmp) {
HXDLIN( 273)			return !(this->isEnumValue(source));
            		}
            		else {
HXDLIN( 273)			return false;
            		}
HXDLIN( 273)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriggerMap_obj,isClassInstance,return )


hx::ObjectPtr< TriggerMap_obj > TriggerMap_obj::__new( ::minject::Injector injector) {
	hx::ObjectPtr< TriggerMap_obj > __this = new TriggerMap_obj();
	__this->__construct(injector);
	return __this;
}

hx::ObjectPtr< TriggerMap_obj > TriggerMap_obj::__alloc(hx::Ctx *_hx_ctx, ::minject::Injector injector) {
	TriggerMap_obj *__this = (TriggerMap_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(TriggerMap_obj), true, "mmvc.base.TriggerMap"));
	*(void **)__this = TriggerMap_obj::_hx_vtable;
	__this->__construct(injector);
	return __this;
}

TriggerMap_obj::TriggerMap_obj()
{
}

void TriggerMap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TriggerMap);
	HX_MARK_MEMBER_NAME(injector,"injector");
	HX_MARK_MEMBER_NAME(classToCommand,"classToCommand");
	HX_MARK_MEMBER_NAME(stringToCommand,"stringToCommand");
	HX_MARK_MEMBER_NAME(enumValueToCommand,"enumValueToCommand");
	HX_MARK_MEMBER_NAME(intToCommand,"intToCommand");
	HX_MARK_MEMBER_NAME(instanceToCommand,"instanceToCommand");
	HX_MARK_END_CLASS();
}

void TriggerMap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(injector,"injector");
	HX_VISIT_MEMBER_NAME(classToCommand,"classToCommand");
	HX_VISIT_MEMBER_NAME(stringToCommand,"stringToCommand");
	HX_VISIT_MEMBER_NAME(enumValueToCommand,"enumValueToCommand");
	HX_VISIT_MEMBER_NAME(intToCommand,"intToCommand");
	HX_VISIT_MEMBER_NAME(instanceToCommand,"instanceToCommand");
}

hx::Val TriggerMap_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"map") ) { return hx::Val( map_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"unmap") ) { return hx::Val( unmap_dyn() ); }
		if (HX_FIELD_EQ(inName,"isInt") ) { return hx::Val( isInt_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"mapInt") ) { return hx::Val( mapInt_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isClass") ) { return hx::Val( isClass_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"injector") ) { return hx::Val( injector ); }
		if (HX_FIELD_EQ(inName,"dispatch") ) { return hx::Val( dispatch_dyn() ); }
		if (HX_FIELD_EQ(inName,"mapClass") ) { return hx::Val( mapClass_dyn() ); }
		if (HX_FIELD_EQ(inName,"unmapInt") ) { return hx::Val( unmapInt_dyn() ); }
		if (HX_FIELD_EQ(inName,"isString") ) { return hx::Val( isString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"mapString") ) { return hx::Val( mapString_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"unmapClass") ) { return hx::Val( unmapClass_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"unmapString") ) { return hx::Val( unmapString_dyn() ); }
		if (HX_FIELD_EQ(inName,"dispatchInt") ) { return hx::Val( dispatchInt_dyn() ); }
		if (HX_FIELD_EQ(inName,"mapInstance") ) { return hx::Val( mapInstance_dyn() ); }
		if (HX_FIELD_EQ(inName,"isEnumValue") ) { return hx::Val( isEnumValue_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"intToCommand") ) { return hx::Val( intToCommand ); }
		if (HX_FIELD_EQ(inName,"mapEnumValue") ) { return hx::Val( mapEnumValue_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"dispatchClass") ) { return hx::Val( dispatchClass_dyn() ); }
		if (HX_FIELD_EQ(inName,"unmapInstance") ) { return hx::Val( unmapInstance_dyn() ); }
		if (HX_FIELD_EQ(inName,"invokeCommand") ) { return hx::Val( invokeCommand_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"classToCommand") ) { return hx::Val( classToCommand ); }
		if (HX_FIELD_EQ(inName,"dispatchString") ) { return hx::Val( dispatchString_dyn() ); }
		if (HX_FIELD_EQ(inName,"unmapEnumValue") ) { return hx::Val( unmapEnumValue_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stringToCommand") ) { return hx::Val( stringToCommand ); }
		if (HX_FIELD_EQ(inName,"isClassInstance") ) { return hx::Val( isClassInstance_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"dispatchInstance") ) { return hx::Val( dispatchInstance_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"instanceToCommand") ) { return hx::Val( instanceToCommand ); }
		if (HX_FIELD_EQ(inName,"dispatchEnumValue") ) { return hx::Val( dispatchEnumValue_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"enumValueToCommand") ) { return hx::Val( enumValueToCommand ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val TriggerMap_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"injector") ) { injector=inValue.Cast<  ::minject::Injector >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"intToCommand") ) { intToCommand=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"classToCommand") ) { classToCommand=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stringToCommand") ) { stringToCommand=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"instanceToCommand") ) { instanceToCommand=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"enumValueToCommand") ) { enumValueToCommand=inValue.Cast<  ::haxe::ds::EnumValueMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TriggerMap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("injector",f4,31,ff,1e));
	outFields->push(HX_("classToCommand",b8,49,f7,37));
	outFields->push(HX_("stringToCommand",ff,3d,2b,3b));
	outFields->push(HX_("enumValueToCommand",40,f2,1f,a5));
	outFields->push(HX_("intToCommand",21,e6,a8,cb));
	outFields->push(HX_("instanceToCommand",bb,4e,af,24));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo TriggerMap_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::minject::Injector*/ ,(int)offsetof(TriggerMap_obj,injector),HX_("injector",f4,31,ff,1e)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(TriggerMap_obj,classToCommand),HX_("classToCommand",b8,49,f7,37)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(TriggerMap_obj,stringToCommand),HX_("stringToCommand",ff,3d,2b,3b)},
	{hx::fsObject /*::haxe::ds::EnumValueMap*/ ,(int)offsetof(TriggerMap_obj,enumValueToCommand),HX_("enumValueToCommand",40,f2,1f,a5)},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(TriggerMap_obj,intToCommand),HX_("intToCommand",21,e6,a8,cb)},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(TriggerMap_obj,instanceToCommand),HX_("instanceToCommand",bb,4e,af,24)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *TriggerMap_obj_sStaticStorageInfo = 0;
#endif

static ::String TriggerMap_obj_sMemberFields[] = {
	HX_("injector",f4,31,ff,1e),
	HX_("classToCommand",b8,49,f7,37),
	HX_("stringToCommand",ff,3d,2b,3b),
	HX_("enumValueToCommand",40,f2,1f,a5),
	HX_("intToCommand",21,e6,a8,cb),
	HX_("instanceToCommand",bb,4e,af,24),
	HX_("map",9c,0a,53,00),
	HX_("unmap",e3,61,ea,a6),
	HX_("dispatch",ba,ce,63,1e),
	HX_("mapClass",fc,e7,9a,bf),
	HX_("unmapClass",55,cf,5e,45),
	HX_("dispatchClass",1e,77,f8,98),
	HX_("mapString",8d,84,0f,f4),
	HX_("unmapString",14,0b,b6,79),
	HX_("dispatchString",2b,33,8f,4c),
	HX_("mapEnumValue",74,a2,36,bd),
	HX_("unmapEnumValue",4d,aa,23,af),
	HX_("dispatchEnumValue",96,6a,a7,e9),
	HX_("mapInt",b3,43,04,b9),
	HX_("unmapInt",cc,72,4b,bb),
	HX_("dispatchInt",55,66,9a,66),
	HX_("mapInstance",51,e2,1b,38),
	HX_("unmapInstance",98,58,56,59),
	HX_("dispatchInstance",6f,f4,da,72),
	HX_("invokeCommand",b3,80,90,ad),
	HX_("isClass",ee,1b,de,e4),
	HX_("isString",5b,c4,99,69),
	HX_("isEnumValue",66,b7,87,06),
	HX_("isInt",25,37,4e,c1),
	HX_("isClassInstance",a3,95,f3,b8),
	::String(null()) };

hx::Class TriggerMap_obj::__mClass;

void TriggerMap_obj::__register()
{
	TriggerMap_obj _hx_dummy;
	TriggerMap_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("mmvc.base.TriggerMap",c0,95,f6,bc);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TriggerMap_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TriggerMap_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriggerMap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriggerMap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace mmvc
} // end namespace base
