// Generated by Haxe 4.0.0-preview.4+1e3e5e0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_snow_api_buffers_ArrayBufferIO
#include <snow/api/buffers/ArrayBufferIO.h>
#endif
#ifndef INCLUDED_snow_api_buffers_ArrayBufferView
#include <snow/api/buffers/ArrayBufferView.h>
#endif
#ifndef INCLUDED_snow_api_buffers_TAError
#include <snow/api/buffers/TAError.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8664b18ab865b55e_12_new,"snow.api.buffers.ArrayBufferView","new",0x3a2b1616,"snow.api.buffers.ArrayBufferView.new","snow/api/buffers/ArrayBufferView.hx",12,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int32Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Int32Array",0xd047b27c,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Int32Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Float32Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Float32Array",0x4cfabfaf,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Float32Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint8Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Uint8Array",0x52f6e86c,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Uint8Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int8Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Int8Array",0x82aea67f,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Int8Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint8ClampedArray,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Uint8ClampedArray",0x26c454ac,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Uint8ClampedArray","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int16Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Int16Array",0x168a3676,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Int16Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint16Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Uint16Array",0x857ba3e9,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Uint16Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint32Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Uint32Array",0x3f391fef,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Uint32Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Float64Array,"snow.api.buffers.ArrayBufferView","subarray_snow_api_buffers_Float64Array",0x9671dcb0,"snow.api.buffers.ArrayBufferView.subarray_snow_api_buffers_Float64Array","snow/api/buffers/ArrayBufferView.hx",160,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_131_set,"snow.api.buffers.ArrayBufferView","set",0x3a2ee158,"snow.api.buffers.ArrayBufferView.set","snow/api/buffers/ArrayBufferView.hx",131,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_145_cloneBuffer,"snow.api.buffers.ArrayBufferView","cloneBuffer",0xdead93f3,"snow.api.buffers.ArrayBufferView.cloneBuffer","snow/api/buffers/ArrayBufferView.hx",145,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_208_bytesForType,"snow.api.buffers.ArrayBufferView","bytesForType",0xd7a3c4c2,"snow.api.buffers.ArrayBufferView.bytesForType","snow/api/buffers/ArrayBufferView.hx",208,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_243_toString,"snow.api.buffers.ArrayBufferView","toString",0x58111736,"snow.api.buffers.ArrayBufferView.toString","snow/api/buffers/ArrayBufferView.hx",243,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_266_toByteLength,"snow.api.buffers.ArrayBufferView","toByteLength",0x3374a2f3,"snow.api.buffers.ArrayBufferView.toByteLength","snow/api/buffers/ArrayBufferView.hx",266,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_273_copyFromArray,"snow.api.buffers.ArrayBufferView","copyFromArray",0x597da290,"snow.api.buffers.ArrayBufferView.copyFromArray","snow/api/buffers/ArrayBufferView.hx",273,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_36_fromElements,"snow.api.buffers.ArrayBufferView","fromElements",0x3e64654b,"snow.api.buffers.ArrayBufferView.fromElements","snow/api/buffers/ArrayBufferView.hx",36,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_56_fromView,"snow.api.buffers.ArrayBufferView","fromView",0xcbbd4779,"snow.api.buffers.ArrayBufferView.fromView","snow/api/buffers/ArrayBufferView.hx",56,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_83_fromBuffer,"snow.api.buffers.ArrayBufferView","fromBuffer",0x15813f14,"snow.api.buffers.ArrayBufferView.fromBuffer","snow/api/buffers/ArrayBufferView.hx",83,0xa074815d)
HX_LOCAL_STACK_FRAME(_hx_pos_8664b18ab865b55e_107_fromArray,"snow.api.buffers.ArrayBufferView","fromArray",0x6873ca05,"snow.api.buffers.ArrayBufferView.fromArray","snow/api/buffers/ArrayBufferView.hx",107,0xa074815d)
namespace snow{
namespace api{
namespace buffers{

void ArrayBufferView_obj::__construct(int in_type){
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_12_new)
HXLINE(  21)		this->bytesPerElement = 0;
HXLINE(  14)		this->type = 0;
HXLINE(  27)		this->type = in_type;
HXLINE(  28)		int _hx_tmp;
HXDLIN(  28)		switch((int)(this->type)){
            			case (int)1: {
HXLINE(  28)				_hx_tmp = 1;
            			}
            			break;
            			case (int)2: {
HXLINE(  28)				_hx_tmp = 2;
            			}
            			break;
            			case (int)3: {
HXLINE(  28)				_hx_tmp = 4;
            			}
            			break;
            			case (int)4: {
HXLINE(  28)				_hx_tmp = 1;
            			}
            			break;
            			case (int)5: {
HXLINE(  28)				_hx_tmp = 1;
            			}
            			break;
            			case (int)6: {
HXLINE(  28)				_hx_tmp = 2;
            			}
            			break;
            			case (int)7: {
HXLINE(  28)				_hx_tmp = 4;
            			}
            			break;
            			case (int)8: {
HXLINE(  28)				_hx_tmp = 4;
            			}
            			break;
            			case (int)9: {
HXLINE(  28)				_hx_tmp = 8;
            			}
            			break;
            			default:{
HXLINE(  28)				_hx_tmp = 1;
            			}
            		}
HXDLIN(  28)		this->bytesPerElement = _hx_tmp;
            	}

Dynamic ArrayBufferView_obj::__CreateEmpty() { return new ArrayBufferView_obj; }

void *ArrayBufferView_obj::_hx_vtable = 0;

Dynamic ArrayBufferView_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ArrayBufferView_obj > _hx_result = new ArrayBufferView_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool ArrayBufferView_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x28adf4de;
}

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Int32Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int32Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Int32Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Float32Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Float32Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Float32Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Uint8Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint8Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Uint8Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Int8Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int8Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Int8Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Uint8ClampedArray(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint8ClampedArray)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Uint8ClampedArray,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Int16Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Int16Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Int16Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Uint16Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint16Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Uint16Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Uint32Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Uint32Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Uint32Array,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::subarray_snow_api_buffers_Float64Array(int begin, ::Dynamic end){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_160_subarray_snow_api_buffers_Float64Array)
HXLINE( 162)		bool _hx_tmp = hx::IsNull( end );
HXLINE( 163)		int byte_len = ((end - begin) * this->bytesPerElement);
HXLINE( 164)		int byte_offset = ((begin * this->bytesPerElement) + this->byteOffset);
HXLINE( 166)		 ::snow::api::buffers::ArrayBufferView view;
HXLINE( 167)		int _g = this->type;
HXDLIN( 167)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 197)				HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            			}
            			break;
            			case (int)1: {
HXLINE( 170)				::Array< unsigned char > _buffer = this->buffer;
HXDLIN( 170)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,1);
HXDLIN( 170)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 170)				if ((byte_offset < 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 170)				if ((hx::Mod(byte_offset,_bytes_per_elem) != 0)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 170)				int _src_bytelen = _buffer->length;
HXDLIN( 170)				int _new_range = (byte_offset + byte_len);
HXDLIN( 170)				if ((_new_range > _src_bytelen)) {
HXLINE( 170)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 170)				_view->buffer = _buffer;
HXDLIN( 170)				_view->byteOffset = byte_offset;
HXDLIN( 170)				_view->byteLength = byte_len;
HXDLIN( 170)				_view->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 166)				view = _view;
            			}
            			break;
            			case (int)2: {
HXLINE( 173)				::Array< unsigned char > _buffer1 = this->buffer;
HXDLIN( 173)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,2);
HXDLIN( 173)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 173)				if ((byte_offset < 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 173)				if ((hx::Mod(byte_offset,_bytes_per_elem1) != 0)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 173)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 173)				int _new_range1 = (byte_offset + byte_len);
HXDLIN( 173)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 173)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 173)				_view1->buffer = _buffer1;
HXDLIN( 173)				_view1->byteOffset = byte_offset;
HXDLIN( 173)				_view1->byteLength = byte_len;
HXDLIN( 173)				_view1->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem1) )));
HXLINE( 166)				view = _view1;
            			}
            			break;
            			case (int)3: {
HXLINE( 176)				::Array< unsigned char > _buffer2 = this->buffer;
HXDLIN( 176)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,3);
HXDLIN( 176)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 176)				if ((byte_offset < 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 176)				if ((hx::Mod(byte_offset,_bytes_per_elem2) != 0)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 176)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 176)				int _new_range2 = (byte_offset + byte_len);
HXDLIN( 176)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 176)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 176)				_view2->buffer = _buffer2;
HXDLIN( 176)				_view2->byteOffset = byte_offset;
HXDLIN( 176)				_view2->byteLength = byte_len;
HXDLIN( 176)				_view2->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem2) )));
HXLINE( 166)				view = _view2;
            			}
            			break;
            			case (int)4: {
HXLINE( 179)				::Array< unsigned char > _buffer3 = this->buffer;
HXDLIN( 179)				 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,4);
HXDLIN( 179)				int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 179)				if ((byte_offset < 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 179)				if ((hx::Mod(byte_offset,_bytes_per_elem3) != 0)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 179)				int _src_bytelen3 = _buffer3->length;
HXDLIN( 179)				int _new_range3 = (byte_offset + byte_len);
HXDLIN( 179)				if ((_new_range3 > _src_bytelen3)) {
HXLINE( 179)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 179)				_view3->buffer = _buffer3;
HXDLIN( 179)				_view3->byteOffset = byte_offset;
HXDLIN( 179)				_view3->byteLength = byte_len;
HXDLIN( 179)				_view3->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem3) )));
HXLINE( 166)				view = _view3;
            			}
            			break;
            			case (int)5: {
HXLINE( 182)				::Array< unsigned char > _buffer4 = this->buffer;
HXDLIN( 182)				 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,5);
HXDLIN( 182)				int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 182)				if ((byte_offset < 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 182)				if ((hx::Mod(byte_offset,_bytes_per_elem4) != 0)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 182)				int _src_bytelen4 = _buffer4->length;
HXDLIN( 182)				int _new_range4 = (byte_offset + byte_len);
HXDLIN( 182)				if ((_new_range4 > _src_bytelen4)) {
HXLINE( 182)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 182)				_view4->buffer = _buffer4;
HXDLIN( 182)				_view4->byteOffset = byte_offset;
HXDLIN( 182)				_view4->byteLength = byte_len;
HXDLIN( 182)				_view4->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem4) )));
HXLINE( 166)				view = _view4;
            			}
            			break;
            			case (int)6: {
HXLINE( 185)				::Array< unsigned char > _buffer5 = this->buffer;
HXDLIN( 185)				 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,6);
HXDLIN( 185)				int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 185)				if ((byte_offset < 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 185)				if ((hx::Mod(byte_offset,_bytes_per_elem5) != 0)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 185)				int _src_bytelen5 = _buffer5->length;
HXDLIN( 185)				int _new_range5 = (byte_offset + byte_len);
HXDLIN( 185)				if ((_new_range5 > _src_bytelen5)) {
HXLINE( 185)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 185)				_view5->buffer = _buffer5;
HXDLIN( 185)				_view5->byteOffset = byte_offset;
HXDLIN( 185)				_view5->byteLength = byte_len;
HXDLIN( 185)				_view5->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem5) )));
HXLINE( 166)				view = _view5;
            			}
            			break;
            			case (int)7: {
HXLINE( 188)				::Array< unsigned char > _buffer6 = this->buffer;
HXDLIN( 188)				 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,7);
HXDLIN( 188)				int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 188)				if ((byte_offset < 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 188)				if ((hx::Mod(byte_offset,_bytes_per_elem6) != 0)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 188)				int _src_bytelen6 = _buffer6->length;
HXDLIN( 188)				int _new_range6 = (byte_offset + byte_len);
HXDLIN( 188)				if ((_new_range6 > _src_bytelen6)) {
HXLINE( 188)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 188)				_view6->buffer = _buffer6;
HXDLIN( 188)				_view6->byteOffset = byte_offset;
HXDLIN( 188)				_view6->byteLength = byte_len;
HXDLIN( 188)				_view6->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem6) )));
HXLINE( 166)				view = _view6;
            			}
            			break;
            			case (int)8: {
HXLINE( 191)				::Array< unsigned char > _buffer7 = this->buffer;
HXDLIN( 191)				 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,8);
HXDLIN( 191)				int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 191)				if ((byte_offset < 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 191)				if ((hx::Mod(byte_offset,_bytes_per_elem7) != 0)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 191)				int _src_bytelen7 = _buffer7->length;
HXDLIN( 191)				int _new_range7 = (byte_offset + byte_len);
HXDLIN( 191)				if ((_new_range7 > _src_bytelen7)) {
HXLINE( 191)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 191)				_view7->buffer = _buffer7;
HXDLIN( 191)				_view7->byteOffset = byte_offset;
HXDLIN( 191)				_view7->byteLength = byte_len;
HXDLIN( 191)				_view7->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem7) )));
HXLINE( 166)				view = _view7;
            			}
            			break;
            			case (int)9: {
HXLINE( 194)				::Array< unsigned char > _buffer8 = this->buffer;
HXDLIN( 194)				 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,9);
HXDLIN( 194)				int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 194)				if ((byte_offset < 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            				}
HXDLIN( 194)				if ((hx::Mod(byte_offset,_bytes_per_elem8) != 0)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 194)				int _src_bytelen8 = _buffer8->length;
HXDLIN( 194)				int _new_range8 = (byte_offset + byte_len);
HXDLIN( 194)				if ((_new_range8 > _src_bytelen8)) {
HXLINE( 194)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 194)				_view8->buffer = _buffer8;
HXDLIN( 194)				_view8->byteOffset = byte_offset;
HXDLIN( 194)				_view8->byteLength = byte_len;
HXDLIN( 194)				_view8->length = ::Std_obj::_hx_int((( (Float)(byte_len) ) / ( (Float)(_bytes_per_elem8) )));
HXLINE( 166)				view = _view8;
            			}
            			break;
            		}
HXLINE( 200)		return view;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,subarray_snow_api_buffers_Float64Array,return )

void ArrayBufferView_obj::set( ::snow::api::buffers::ArrayBufferView view,::Array< Float > array,hx::Null< int >  __o_offset){
int offset = __o_offset.Default(0);
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_131_set)
HXDLIN( 131)		bool _hx_tmp;
HXDLIN( 131)		if (hx::IsNotNull( view )) {
HXDLIN( 131)			_hx_tmp = hx::IsNull( array );
            		}
            		else {
HXDLIN( 131)			_hx_tmp = false;
            		}
HXDLIN( 131)		if (_hx_tmp) {
HXLINE( 132)			this->buffer->blit((offset * this->bytesPerElement),view->buffer,view->byteOffset,view->byteLength);
            		}
            		else {
HXLINE( 133)			bool _hx_tmp1;
HXDLIN( 133)			if (hx::IsNotNull( array )) {
HXLINE( 133)				_hx_tmp1 = hx::IsNull( view );
            			}
            			else {
HXLINE( 133)				_hx_tmp1 = false;
            			}
HXDLIN( 133)			if (_hx_tmp1) {
HXLINE( 134)				this->copyFromArray(array,offset);
            			}
            			else {
HXLINE( 136)				HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(ArrayBufferView_obj,set,(void))

void ArrayBufferView_obj::cloneBuffer(::Array< unsigned char > src,hx::Null< int >  __o_srcByteOffset){
int srcByteOffset = __o_srcByteOffset.Default(0);
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_145_cloneBuffer)
HXLINE( 147)		int srcLength = src->length;
HXLINE( 148)		int cloneLength = (srcLength - srcByteOffset);
HXLINE( 150)		::Array< unsigned char > this1 = ::Array_obj< unsigned char >::__new();
HXDLIN( 150)		if ((cloneLength > 0)) {
HXLINE( 150)			this1[(cloneLength - 1)] = ( (unsigned char)(0) );
            		}
HXDLIN( 150)		this->buffer = this1;
HXLINE( 152)		this->buffer->blit(0,src,srcByteOffset,cloneLength);
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,cloneBuffer,(void))

int ArrayBufferView_obj::bytesForType(int type){
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_208_bytesForType)
HXDLIN( 208)		switch((int)(type)){
            			case (int)1: {
HXLINE( 211)				return 1;
            			}
            			break;
            			case (int)2: {
HXLINE( 220)				return 2;
            			}
            			break;
            			case (int)3: {
HXLINE( 226)				return 4;
            			}
            			break;
            			case (int)4: {
HXLINE( 214)				return 1;
            			}
            			break;
            			case (int)5: {
HXLINE( 217)				return 1;
            			}
            			break;
            			case (int)6: {
HXLINE( 223)				return 2;
            			}
            			break;
            			case (int)7: {
HXLINE( 229)				return 4;
            			}
            			break;
            			case (int)8: {
HXLINE( 232)				return 4;
            			}
            			break;
            			case (int)9: {
HXLINE( 235)				return 8;
            			}
            			break;
            			default:{
HXLINE( 237)				return 1;
            			}
            		}
HXLINE( 208)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArrayBufferView_obj,bytesForType,return )

::String ArrayBufferView_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_243_toString)
HXLINE( 245)		::String name;
HXLINE( 246)		int _g = this->type;
HXDLIN( 246)		switch((int)(_g)){
            			case (int)1: {
HXLINE( 245)				name = HX_("Int8Array",50,dc,f6,ae);
            			}
            			break;
            			case (int)2: {
HXLINE( 245)				name = HX_("Int16Array",85,17,71,a9);
            			}
            			break;
            			case (int)3: {
HXLINE( 245)				name = HX_("Int32Array",8b,93,2e,63);
            			}
            			break;
            			case (int)4: {
HXLINE( 245)				name = HX_("Uint8Array",7b,c9,dd,e5);
            			}
            			break;
            			case (int)5: {
HXLINE( 245)				name = HX_("Uint8ClampedArray",7d,43,e0,0c);
            			}
            			break;
            			case (int)6: {
HXLINE( 245)				name = HX_("Uint16Array",fa,af,99,7c);
            			}
            			break;
            			case (int)7: {
HXLINE( 245)				name = HX_("Uint32Array",00,2c,57,36);
            			}
            			break;
            			case (int)8: {
HXLINE( 245)				name = HX_("Float32Array",7e,42,27,90);
            			}
            			break;
            			case (int)9: {
HXLINE( 245)				name = HX_("Float64Array",7f,5f,9e,d9);
            			}
            			break;
            			default:{
HXLINE( 245)				name = HX_("ArrayBufferView",5e,6e,84,fd);
            			}
            		}
HXLINE( 259)		return (name + ((((HX_(" [byteLength:",11,d6,a9,ca) + this->byteLength) + HX_(", length:",a0,04,67,ef)) + this->length) + HX_("]",5d,00,00,00)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ArrayBufferView_obj,toString,return )

int ArrayBufferView_obj::toByteLength(int elemCount){
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_266_toByteLength)
HXDLIN( 266)		return (elemCount * this->bytesPerElement);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArrayBufferView_obj,toByteLength,return )

void ArrayBufferView_obj::copyFromArray(::Array< Float > array, ::Dynamic __o_offset){
 ::Dynamic offset = __o_offset.Default(0);
            	HX_STACKFRAME(&_hx_pos_8664b18ab865b55e_273_copyFromArray)
HXLINE( 276)		int i = 0;
HXDLIN( 276)		int len = array->length;
HXLINE( 278)		{
HXLINE( 278)			int _g = this->type;
HXDLIN( 278)			switch((int)(_g)){
            				case (int)0: {
HXLINE( 344)					HX_STACK_DO_THROW(HX_("copyFromArray on a base type ArrayBuffer",e8,01,1a,e2));
            				}
            				break;
            				case (int)1: {
HXLINE( 280)					while((i < len)){
HXLINE( 281)						int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 282)						{
HXLINE( 282)							::Array< unsigned char > buffer = this->buffer;
HXDLIN( 282)							 ::__hxcpp_memory_set_byte(buffer,pos,::Std_obj::_hx_int(array->__get(i)));
            						}
HXLINE( 284)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 287)					while((i < len)){
HXLINE( 288)						int pos1 = ((offset + i) * this->bytesPerElement);
HXLINE( 289)						::Array< unsigned char > _hx_tmp = this->buffer;
HXDLIN( 289)						::snow::api::buffers::ArrayBufferIO_obj::setInt16(_hx_tmp,pos1,::Std_obj::_hx_int(array->__get(i)));
HXLINE( 291)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 294)					while((i < len)){
HXLINE( 295)						int pos2 = ((offset + i) * this->bytesPerElement);
HXLINE( 296)						{
HXLINE( 296)							::Array< unsigned char > buffer1 = this->buffer;
HXDLIN( 296)							 ::__hxcpp_memory_set_i32(buffer1,pos2,::Std_obj::_hx_int(array->__get(i)));
            						}
HXLINE( 298)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)4: {
HXLINE( 301)					while((i < len)){
HXLINE( 302)						int pos3 = ((offset + i) * this->bytesPerElement);
HXLINE( 303)						{
HXLINE( 303)							::Array< unsigned char > buffer2 = this->buffer;
HXDLIN( 303)							 ::__hxcpp_memory_set_byte(buffer2,pos3,::Std_obj::_hx_int(array->__get(i)));
            						}
HXLINE( 305)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)5: {
HXLINE( 322)					while((i < len)){
HXLINE( 323)						int pos4 = ((offset + i) * this->bytesPerElement);
HXLINE( 324)						{
HXLINE( 324)							::Array< unsigned char > buffer3 = this->buffer;
HXDLIN( 324)							{
HXLINE( 324)								int _out = ::Std_obj::_hx_int(( (Float)(::Std_obj::_hx_int(array->__get(i))) ));
HXDLIN( 324)								if ((_out > 255)) {
HXLINE( 324)									_out = 255;
            								}
            								else {
HXLINE( 324)									_out = _out;
            								}
HXDLIN( 324)								int value;
HXDLIN( 324)								if ((_out < 0)) {
HXLINE( 324)									value = 0;
            								}
            								else {
HXLINE( 324)									value = _out;
            								}
HXDLIN( 324)								 ::__hxcpp_memory_set_byte(buffer3,pos4,value);
            							}
            						}
HXLINE( 326)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)6: {
HXLINE( 308)					while((i < len)){
HXLINE( 309)						int pos5 = ((offset + i) * this->bytesPerElement);
HXLINE( 310)						{
HXLINE( 310)							::Array< unsigned char > buffer4 = this->buffer;
HXDLIN( 310)							 ::__hxcpp_memory_set_ui16(buffer4,pos5,::Std_obj::_hx_int(array->__get(i)));
            						}
HXLINE( 312)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)7: {
HXLINE( 315)					while((i < len)){
HXLINE( 316)						int pos6 = ((offset + i) * this->bytesPerElement);
HXLINE( 317)						{
HXLINE( 317)							::Array< unsigned char > buffer5 = this->buffer;
HXDLIN( 317)							 ::__hxcpp_memory_set_ui32(buffer5,pos6,::Std_obj::_hx_int(array->__get(i)));
            						}
HXLINE( 319)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)8: {
HXLINE( 329)					while((i < len)){
HXLINE( 330)						int pos7 = ((offset + i) * this->bytesPerElement);
HXLINE( 331)						 ::__hxcpp_memory_set_float(this->buffer,pos7,array->__get(i));
HXLINE( 333)						i = (i + 1);
            					}
            				}
            				break;
            				case (int)9: {
HXLINE( 336)					while((i < len)){
HXLINE( 337)						int pos8 = ((offset + i) * this->bytesPerElement);
HXLINE( 338)						 ::__hxcpp_memory_set_double(this->buffer,pos8,array->__get(i));
HXLINE( 340)						i = (i + 1);
            					}
            				}
            				break;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,copyFromArray,(void))

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::fromElements(int _type,int _elements){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_36_fromElements)
HXLINE(  38)		if ((_elements < 0)) {
HXLINE(  38)			_elements = 0;
            		}
HXLINE(  42)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,_type);
HXLINE(  43)		int _bytelen = (_elements * _view->bytesPerElement);
HXLINE(  45)		_view->byteOffset = 0;
HXLINE(  46)		_view->byteLength = _bytelen;
HXLINE(  47)		::Array< unsigned char > this1 = ::Array_obj< unsigned char >::__new();
HXDLIN(  47)		if ((_bytelen > 0)) {
HXLINE(  47)			this1[(_bytelen - 1)] = ( (unsigned char)(0) );
            		}
HXDLIN(  47)		_view->buffer = this1;
HXLINE(  48)		_view->length = _elements;
HXLINE(  50)		return _view;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,fromElements,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::fromView(int _type, ::snow::api::buffers::ArrayBufferView _other){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_56_fromView)
HXLINE(  58)		int _src_type = _other->type;
HXLINE(  59)		::Array< unsigned char > _src_data = _other->buffer;
HXLINE(  60)		int _src_length = _other->length;
HXLINE(  61)		int _src_byte_offset = _other->byteOffset;
HXLINE(  63)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,_type);
HXLINE(  67)		if ((_src_type == _type)) {
HXLINE(  68)			int srcLength = _src_data->length;
HXDLIN(  68)			int cloneLength = (srcLength - _src_byte_offset);
HXDLIN(  68)			::Array< unsigned char > this1 = ::Array_obj< unsigned char >::__new();
HXDLIN(  68)			if ((cloneLength > 0)) {
HXLINE(  68)				this1[(cloneLength - 1)] = ( (unsigned char)(0) );
            			}
HXDLIN(  68)			_view->buffer = this1;
HXDLIN(  68)			_view->buffer->blit(0,_src_data,_src_byte_offset,cloneLength);
            		}
            		else {
HXLINE(  70)			HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            		}
HXLINE(  73)		_view->byteLength = (_view->bytesPerElement * _src_length);
HXLINE(  74)		_view->byteOffset = 0;
HXLINE(  75)		_view->length = _src_length;
HXLINE(  77)		return _view;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,fromView,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::fromBuffer(int _type,::Array< unsigned char > _buffer,int _byte_offset,int _byte_length){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_83_fromBuffer)
HXLINE(  85)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,_type);
HXLINE(  86)		int _bytes_per_elem = _view->bytesPerElement;
HXLINE(  88)		if ((_byte_offset < 0)) {
HXLINE(  88)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be positive (> 0)",07,9d,c2,39)));
            		}
HXLINE(  89)		if ((hx::Mod(_byte_offset,_bytes_per_elem) != 0)) {
HXLINE(  89)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            		}
HXLINE(  91)		int _src_bytelen = _buffer->length;
HXLINE(  92)		int _new_range = (_byte_offset + _byte_length);
HXLINE(  93)		if ((_new_range > _src_bytelen)) {
HXLINE(  93)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            		}
HXLINE(  95)		_view->buffer = _buffer;
HXLINE(  96)		_view->byteOffset = _byte_offset;
HXLINE(  97)		_view->byteLength = _byte_length;
HXLINE(  98)		_view->length = ::Std_obj::_hx_int((( (Float)(_byte_length) ) / ( (Float)(_bytes_per_elem) )));
HXLINE( 100)		return _view;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(ArrayBufferView_obj,fromBuffer,return )

 ::snow::api::buffers::ArrayBufferView ArrayBufferView_obj::fromArray(int _type,::Array< Float > _array){
            	HX_GC_STACKFRAME(&_hx_pos_8664b18ab865b55e_107_fromArray)
HXLINE( 109)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,_type);
HXLINE( 110)		int _length = _array->length;
HXLINE( 111)		int _bytelen = (_length * _view->bytesPerElement);
HXLINE( 113)		_view->byteOffset = 0;
HXLINE( 114)		_view->length = _length;
HXLINE( 115)		_view->byteLength = _bytelen;
HXLINE( 116)		::Array< unsigned char > this1 = ::Array_obj< unsigned char >::__new();
HXDLIN( 116)		if ((_bytelen > 0)) {
HXLINE( 116)			this1[(_bytelen - 1)] = ( (unsigned char)(0) );
            		}
HXDLIN( 116)		_view->buffer = this1;
HXLINE( 118)		_view->copyFromArray(_array,null());
HXLINE( 120)		return _view;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,fromArray,return )


hx::ObjectPtr< ArrayBufferView_obj > ArrayBufferView_obj::__new(int in_type) {
	hx::ObjectPtr< ArrayBufferView_obj > __this = new ArrayBufferView_obj();
	__this->__construct(in_type);
	return __this;
}

hx::ObjectPtr< ArrayBufferView_obj > ArrayBufferView_obj::__alloc(hx::Ctx *_hx_ctx,int in_type) {
	ArrayBufferView_obj *__this = (ArrayBufferView_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ArrayBufferView_obj), true, "snow.api.buffers.ArrayBufferView"));
	*(void **)__this = ArrayBufferView_obj::_hx_vtable;
	__this->__construct(in_type);
	return __this;
}

ArrayBufferView_obj::ArrayBufferView_obj()
{
}

void ArrayBufferView_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ArrayBufferView);
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(byteOffset,"byteOffset");
	HX_MARK_MEMBER_NAME(byteLength,"byteLength");
	HX_MARK_MEMBER_NAME(length,"length");
	HX_MARK_MEMBER_NAME(bytesPerElement,"bytesPerElement");
	HX_MARK_END_CLASS();
}

void ArrayBufferView_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(byteOffset,"byteOffset");
	HX_VISIT_MEMBER_NAME(byteLength,"byteLength");
	HX_VISIT_MEMBER_NAME(length,"length");
	HX_VISIT_MEMBER_NAME(bytesPerElement,"bytesPerElement");
}

hx::Val ArrayBufferView_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"set") ) { return hx::Val( set_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { return hx::Val( buffer ); }
		if (HX_FIELD_EQ(inName,"length") ) { return hx::Val( length ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"byteOffset") ) { return hx::Val( byteOffset ); }
		if (HX_FIELD_EQ(inName,"byteLength") ) { return hx::Val( byteLength ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cloneBuffer") ) { return hx::Val( cloneBuffer_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"bytesForType") ) { return hx::Val( bytesForType_dyn() ); }
		if (HX_FIELD_EQ(inName,"toByteLength") ) { return hx::Val( toByteLength_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"copyFromArray") ) { return hx::Val( copyFromArray_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"bytesPerElement") ) { return hx::Val( bytesPerElement ); }
		break;
	case 35:
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Int8Array") ) { return hx::Val( subarray_snow_api_buffers_Int8Array_dyn() ); }
		break;
	case 36:
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Int32Array") ) { return hx::Val( subarray_snow_api_buffers_Int32Array_dyn() ); }
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Uint8Array") ) { return hx::Val( subarray_snow_api_buffers_Uint8Array_dyn() ); }
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Int16Array") ) { return hx::Val( subarray_snow_api_buffers_Int16Array_dyn() ); }
		break;
	case 37:
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Uint16Array") ) { return hx::Val( subarray_snow_api_buffers_Uint16Array_dyn() ); }
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Uint32Array") ) { return hx::Val( subarray_snow_api_buffers_Uint32Array_dyn() ); }
		break;
	case 38:
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Float32Array") ) { return hx::Val( subarray_snow_api_buffers_Float32Array_dyn() ); }
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Float64Array") ) { return hx::Val( subarray_snow_api_buffers_Float64Array_dyn() ); }
		break;
	case 43:
		if (HX_FIELD_EQ(inName,"subarray_snow_api_buffers_Uint8ClampedArray") ) { return hx::Val( subarray_snow_api_buffers_Uint8ClampedArray_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ArrayBufferView_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"fromView") ) { outValue = fromView_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromArray") ) { outValue = fromArray_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fromBuffer") ) { outValue = fromBuffer_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fromElements") ) { outValue = fromElements_dyn(); return true; }
	}
	return false;
}

hx::Val ArrayBufferView_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast< ::Array< unsigned char > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"length") ) { length=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"byteOffset") ) { byteOffset=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"byteLength") ) { byteLength=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"bytesPerElement") ) { bytesPerElement=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArrayBufferView_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("buffer",00,bd,94,d0));
	outFields->push(HX_("byteOffset",bb,20,44,38));
	outFields->push(HX_("byteLength",0e,1e,0c,77));
	outFields->push(HX_("length",e6,94,07,9f));
	outFields->push(HX_("bytesPerElement",aa,67,89,18));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo ArrayBufferView_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(ArrayBufferView_obj,type),HX_("type",ba,f2,08,4d)},
	{hx::fsObject /*Array< unsigned char >*/ ,(int)offsetof(ArrayBufferView_obj,buffer),HX_("buffer",00,bd,94,d0)},
	{hx::fsInt,(int)offsetof(ArrayBufferView_obj,byteOffset),HX_("byteOffset",bb,20,44,38)},
	{hx::fsInt,(int)offsetof(ArrayBufferView_obj,byteLength),HX_("byteLength",0e,1e,0c,77)},
	{hx::fsInt,(int)offsetof(ArrayBufferView_obj,length),HX_("length",e6,94,07,9f)},
	{hx::fsInt,(int)offsetof(ArrayBufferView_obj,bytesPerElement),HX_("bytesPerElement",aa,67,89,18)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ArrayBufferView_obj_sStaticStorageInfo = 0;
#endif

static ::String ArrayBufferView_obj_sMemberFields[] = {
	HX_("subarray_snow_api_buffers_Int32Array",f2,90,b7,ec),
	HX_("subarray_snow_api_buffers_Float32Array",a5,a7,f7,4b),
	HX_("subarray_snow_api_buffers_Uint8Array",e2,c6,66,6f),
	HX_("subarray_snow_api_buffers_Int8Array",c9,c8,9c,d6),
	HX_("subarray_snow_api_buffers_Uint8ClampedArray",f6,d0,6c,22),
	HX_("subarray_snow_api_buffers_Int16Array",ec,14,fa,32),
	HX_("subarray_snow_api_buffers_Uint16Array",b3,6c,ee,4a),
	HX_("subarray_snow_api_buffers_Uint32Array",b9,e8,ab,04),
	HX_("subarray_snow_api_buffers_Float64Array",a6,c4,6e,95),
	HX_("type",ba,f2,08,4d),
	HX_("buffer",00,bd,94,d0),
	HX_("byteOffset",bb,20,44,38),
	HX_("byteLength",0e,1e,0c,77),
	HX_("length",e6,94,07,9f),
	HX_("bytesPerElement",aa,67,89,18),
	HX_("set",a2,9b,57,00),
	HX_("cloneBuffer",3d,a8,e8,6c),
	HX_("bytesForType",38,71,1a,bd),
	HX_("toString",ac,d0,6e,38),
	HX_("toByteLength",69,4f,eb,18),
	HX_("copyFromArray",5a,dd,dd,3b),
	::String(null()) };

hx::Class ArrayBufferView_obj::__mClass;

static ::String ArrayBufferView_obj_sStaticFields[] = {
	HX_("fromElements",c1,11,db,23),
	HX_("fromView",ef,00,1b,ac),
	HX_("fromBuffer",0a,c2,d8,13),
	HX_("fromArray",cf,57,18,da),
	::String(null())
};

void ArrayBufferView_obj::__register()
{
	ArrayBufferView_obj _hx_dummy;
	ArrayBufferView_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("snow.api.buffers.ArrayBufferView",24,13,7d,c1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ArrayBufferView_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(ArrayBufferView_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ArrayBufferView_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ArrayBufferView_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArrayBufferView_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArrayBufferView_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace snow
} // end namespace api
} // end namespace buffers
