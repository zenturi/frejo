// Generated by Haxe 4.0.0-preview.4+1e3e5e0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_minject_Reflector
#include <minject/Reflector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d11d6f47989ab043_30_new,"minject.Reflector","new",0x30f5d5c2,"minject.Reflector.new","minject/Reflector.hx",30,0xc1f4156f)
HX_LOCAL_STACK_FRAME(_hx_pos_d11d6f47989ab043_40_classExtendsOrImplements,"minject.Reflector","classExtendsOrImplements",0x0899dd72,"minject.Reflector.classExtendsOrImplements","minject/Reflector.hx",40,0xc1f4156f)
HX_LOCAL_STACK_FRAME(_hx_pos_d11d6f47989ab043_87_getFQCN,"minject.Reflector","getFQCN",0xadf982ae,"minject.Reflector.getFQCN","minject/Reflector.hx",87,0xc1f4156f)
namespace minject{

void Reflector_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d11d6f47989ab043_30_new)
            	}

Dynamic Reflector_obj::__CreateEmpty() { return new Reflector_obj; }

void *Reflector_obj::_hx_vtable = 0;

Dynamic Reflector_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Reflector_obj > _hx_result = new Reflector_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Reflector_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x72d745c2;
}

bool Reflector_obj::classExtendsOrImplements( ::Dynamic classOrClassName,hx::Class superClass){
            	HX_STACKFRAME(&_hx_pos_d11d6f47989ab043_40_classExtendsOrImplements)
HXLINE(  41)		hx::Class actualClass = null();
HXLINE(  43)		if (::Std_obj::is(classOrClassName,hx::ClassOf< ::hx::Class >())) {
HXLINE(  45)			actualClass = hx::TCast< hx::Class >::cast(classOrClassName);
            		}
            		else {
HXLINE(  47)			if (::Std_obj::is(classOrClassName,hx::ClassOf< ::String >())) {
HXLINE(  49)				try {
            					HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  51)					actualClass = ::Type_obj::resolveClass(hx::TCast< ::String >::cast(classOrClassName));
            				}
            				catch( ::Dynamic _hx_e){
            					if (_hx_e.IsClass<  ::Dynamic >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::Dynamic e = _hx_e;
HXLINE(  55)						::String _hx_tmp = ((HX_("The class name ",3e,0f,7e,5a) + ::Std_obj::string(classOrClassName)) + HX_(" is not valid because of ",c8,e5,79,e5));
HXDLIN(  55)						::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(e)) + HX_("\n",0a,00,00,00));
HXDLIN(  55)						HX_STACK_DO_THROW((_hx_tmp1 + ::Std_obj::string(e->__Field(HX_("getStackTrace",53,8e,b0,85),hx::paccDynamic)())));
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
            			}
            		}
HXLINE(  59)		if (hx::IsNull( actualClass )) {
HXLINE(  61)			HX_STACK_DO_THROW(HX_("The parameter classOrClassName must be a Class or fully qualified class name.",03,22,97,8e));
            		}
HXLINE(  64)		 ::Dynamic classInstance = ::Type_obj::createEmptyInstance(actualClass);
HXLINE(  65)		return ::Std_obj::is(classInstance,superClass);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Reflector_obj,classExtendsOrImplements,return )

::String Reflector_obj::getFQCN( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_d11d6f47989ab043_87_getFQCN)
HXLINE(  88)		::String fqcn;
HXLINE(  90)		if (::Std_obj::is(value,hx::ClassOf< ::String >())) {
HXLINE(  92)			return hx::TCast< ::String >::cast(value);
            		}
HXLINE(  95)		return ::Type_obj::getClassName(value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Reflector_obj,getFQCN,return )


hx::ObjectPtr< Reflector_obj > Reflector_obj::__new() {
	hx::ObjectPtr< Reflector_obj > __this = new Reflector_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Reflector_obj > Reflector_obj::__alloc(hx::Ctx *_hx_ctx) {
	Reflector_obj *__this = (Reflector_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Reflector_obj), false, "minject.Reflector"));
	*(void **)__this = Reflector_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Reflector_obj::Reflector_obj()
{
}

hx::Val Reflector_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"getFQCN") ) { return hx::Val( getFQCN_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"classExtendsOrImplements") ) { return hx::Val( classExtendsOrImplements_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *Reflector_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *Reflector_obj_sStaticStorageInfo = 0;
#endif

static ::String Reflector_obj_sMemberFields[] = {
	HX_("classExtendsOrImplements",14,8a,0f,7b),
	HX_("getFQCN",4c,24,2c,16),
	::String(null()) };

hx::Class Reflector_obj::__mClass;

void Reflector_obj::__register()
{
	Reflector_obj _hx_dummy;
	Reflector_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("minject.Reflector",d0,8c,2b,44);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Reflector_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Reflector_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Reflector_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Reflector_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace minject
