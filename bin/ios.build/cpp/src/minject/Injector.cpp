// Generated by Haxe 4.0.0-preview.4+1e3e5e0
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_rtti_Meta
#include <haxe/rtti/Meta.h>
#endif
#ifndef INCLUDED_minject_InjecteeDescription
#include <minject/InjecteeDescription.h>
#endif
#ifndef INCLUDED_minject_InjecteeSet
#include <minject/InjecteeSet.h>
#endif
#ifndef INCLUDED_minject_InjectionConfig
#include <minject/InjectionConfig.h>
#endif
#ifndef INCLUDED_minject_Injector
#include <minject/Injector.h>
#endif
#ifndef INCLUDED_minject_point_ConstructorInjectionPoint
#include <minject/point/ConstructorInjectionPoint.h>
#endif
#ifndef INCLUDED_minject_point_InjectionPoint
#include <minject/point/InjectionPoint.h>
#endif
#ifndef INCLUDED_minject_point_MethodInjectionPoint
#include <minject/point/MethodInjectionPoint.h>
#endif
#ifndef INCLUDED_minject_point_NoParamsConstructorInjectionPoint
#include <minject/point/NoParamsConstructorInjectionPoint.h>
#endif
#ifndef INCLUDED_minject_point_PostConstructInjectionPoint
#include <minject/point/PostConstructInjectionPoint.h>
#endif
#ifndef INCLUDED_minject_point_PropertyInjectionPoint
#include <minject/point/PropertyInjectionPoint.h>
#endif
#ifndef INCLUDED_minject_result_InjectValueResult
#include <minject/result/InjectValueResult.h>
#endif
#ifndef INCLUDED_minject_result_InjectionResult
#include <minject/result/InjectionResult.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_738cdc6e32f3b607_58_new,"minject.Injector","new",0xcf0b7cb6,"minject.Injector.new","minject/Injector.hx",58,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_77_mapValue,"minject.Injector","mapValue",0xe7a4cb1f,"minject.Injector.mapValue","minject/Injector.hx",77,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_159_getMapping,"minject.Injector","getMapping",0x35a42b82,"minject.Injector.getMapping","minject/Injector.hx",159,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_180_injectInto,"minject.Injector","injectInto",0xcb4e023b,"minject.Injector.injectInto","minject/Injector.hx",180,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_218_construct,"minject.Injector","construct",0xe5a3e8ed,"minject.Injector.construct","minject/Injector.hx",218,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_250_instantiate,"minject.Injector","instantiate",0xe2f4b500,"minject.Injector.instantiate","minject/Injector.hx",250,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_263_unmap,"minject.Injector","unmap",0x54264fb9,"minject.Injector.unmap","minject/Injector.hx",263,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_282_hasMapping,"minject.Injector","hasMapping",0x70f68d3e,"minject.Injector.hasMapping","minject/Injector.hx",282,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_318_createChildInjector,"minject.Injector","createChildInjector",0xa4e7076a,"minject.Injector.createChildInjector","minject/Injector.hx",318,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_329_getAncestorMapping,"minject.Injector","getAncestorMapping",0x5a1ce36f,"minject.Injector.getAncestorMapping","minject/Injector.hx",329,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_348_getInjectionPoints,"minject.Injector","getInjectionPoints",0x3746b9ce,"minject.Injector.getInjectionPoints","minject/Injector.hx",348,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_403_getInjectionPoints,"minject.Injector","getInjectionPoints",0x3746b9ce,"minject.Injector.getInjectionPoints","minject/Injector.hx",403,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_416_getConfigurationForRequest,"minject.Injector","getConfigurationForRequest",0xa18ba010,"minject.Injector.getConfigurationForRequest","minject/Injector.hx",416,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_431_set_parentInjector,"minject.Injector","set_parentInjector",0xfc17e4e5,"minject.Injector.set_parentInjector","minject/Injector.hx",431,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_445_getClassName,"minject.Injector","getClassName",0xaf8b4817,"minject.Injector.getClassName","minject/Injector.hx",445,0x21627919)
HX_LOCAL_STACK_FRAME(_hx_pos_738cdc6e32f3b607_450_getFields,"minject.Injector","getFields",0x92dba885,"minject.Injector.getFields","minject/Injector.hx",450,0x21627919)
namespace minject{

void Injector_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_58_new)
HXLINE(  59)		this->injectionConfigs =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  60)		this->injecteeDescriptions =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE(  61)		this->attendedToInjectees =  ::minject::InjecteeSet_obj::__alloc( HX_CTX );
            	}

Dynamic Injector_obj::__CreateEmpty() { return new Injector_obj; }

void *Injector_obj::_hx_vtable = 0;

Dynamic Injector_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Injector_obj > _hx_result = new Injector_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Injector_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1d8a734a;
}

 ::Dynamic Injector_obj::mapValue(hx::Class whenAskedFor, ::Dynamic useValue,::String __o_named){
::String named = __o_named.Default(HX_("",00,00,00,00));
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_77_mapValue)
HXLINE(  78)		 ::minject::InjectionConfig config = this->getMapping(whenAskedFor,named);
HXLINE(  79)		config->setResult( ::minject::result::InjectValueResult_obj::__alloc( HX_CTX ,useValue));
HXLINE(  80)		return config;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Injector_obj,mapValue,return )

 ::minject::InjectionConfig Injector_obj::getMapping(hx::Class forClass,::String __o_named){
::String named = __o_named.Default(HX_("",00,00,00,00));
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_159_getMapping)
HXLINE( 160)		::String requestName = ((this->getClassName(forClass) + HX_("#",23,00,00,00)) + named);
HXLINE( 162)		if (this->injectionConfigs->exists(requestName)) {
HXLINE( 164)			return ( ( ::minject::InjectionConfig)(this->injectionConfigs->get(requestName)) );
            		}
HXLINE( 167)		 ::minject::InjectionConfig config =  ::minject::InjectionConfig_obj::__alloc( HX_CTX ,forClass,named);
HXLINE( 168)		this->injectionConfigs->set(requestName,config);
HXLINE( 169)		return config;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Injector_obj,getMapping,return )

void Injector_obj::injectInto( ::Dynamic target){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_180_injectInto)
HXLINE( 181)		if (this->attendedToInjectees->contains(target)) {
HXLINE( 183)			return;
            		}
HXLINE( 186)		this->attendedToInjectees->add(target);
HXLINE( 189)		hx::Class targetClass = ::Type_obj::getClass(target);
HXLINE( 191)		 ::minject::InjecteeDescription injecteeDescription = null();
HXLINE( 193)		if (this->injecteeDescriptions->exists(targetClass)) {
HXLINE( 195)			injecteeDescription = ( ( ::minject::InjecteeDescription)(this->injecteeDescriptions->get(targetClass)) );
            		}
            		else {
HXLINE( 199)			injecteeDescription = this->getInjectionPoints(targetClass);
            		}
HXLINE( 202)		if (hx::IsNull( injecteeDescription )) {
HXLINE( 202)			return;
            		}
HXLINE( 204)		::cpp::VirtualArray injectionPoints = injecteeDescription->injectionPoints;
HXLINE( 205)		int length = injectionPoints->get_length();
HXLINE( 207)		{
HXLINE( 207)			int _g1 = 0;
HXDLIN( 207)			int _g = length;
HXDLIN( 207)			while((_g1 < _g)){
HXLINE( 207)				_g1 = (_g1 + 1);
HXDLIN( 207)				int i = (_g1 - 1);
HXLINE( 209)				::Dynamic injectionPoint = injectionPoints->__get(i);
HXLINE( 210)				::minject::point::InjectionPoint_obj::applyInjection(injectionPoint,target,hx::ObjectPtr<OBJ_>(this));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,injectInto,(void))

 ::Dynamic Injector_obj::construct(hx::Class theClass){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_218_construct)
HXLINE( 219)		 ::minject::InjecteeDescription injecteeDescription;
HXLINE( 221)		if (this->injecteeDescriptions->exists(theClass)) {
HXLINE( 223)			injecteeDescription = ( ( ::minject::InjecteeDescription)(this->injecteeDescriptions->get(theClass)) );
            		}
            		else {
HXLINE( 227)			injecteeDescription = this->getInjectionPoints(theClass);
            		}
HXLINE( 230)		::Dynamic injectionPoint = injecteeDescription->ctor;
HXLINE( 231)		return ::minject::point::InjectionPoint_obj::applyInjection(injectionPoint,theClass,hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,construct,return )

 ::Dynamic Injector_obj::instantiate(hx::Class theClass){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_250_instantiate)
HXLINE( 251)		 ::Dynamic instance = this->construct(theClass);
HXLINE( 252)		this->injectInto(instance);
HXLINE( 253)		return instance;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,instantiate,return )

void Injector_obj::unmap(hx::Class theClass,::String __o_named){
::String named = __o_named.Default(HX_("",00,00,00,00));
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_263_unmap)
HXLINE( 264)		 ::minject::InjectionConfig mapping = this->getConfigurationForRequest(theClass,named,null());
HXLINE( 266)		if (hx::IsNull( mapping )) {
HXLINE( 268)			HX_STACK_DO_THROW(((((HX_("Error while removing an injector mapping: No mapping defined for class ",e4,45,2a,4c) + this->getClassName(theClass)) + HX_(", named \"",07,1c,5f,14)) + named) + HX_("\"",22,00,00,00)));
            		}
HXLINE( 271)		mapping->setResult(null());
            	}


HX_DEFINE_DYNAMIC_FUNC2(Injector_obj,unmap,(void))

bool Injector_obj::hasMapping(hx::Class forClass,::String __o_named){
::String named = __o_named.Default(HX_("",00,00,00,00));
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_282_hasMapping)
HXLINE( 283)		 ::minject::InjectionConfig mapping = this->getConfigurationForRequest(forClass,named,null());
HXLINE( 285)		if (hx::IsNull( mapping )) {
HXLINE( 287)			return false;
            		}
HXLINE( 290)		return mapping->hasResponse(hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Injector_obj,hasMapping,return )

 ::minject::Injector Injector_obj::createChildInjector(){
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_318_createChildInjector)
HXLINE( 319)		 ::minject::Injector injector =  ::minject::Injector_obj::__alloc( HX_CTX );
HXLINE( 320)		injector->set_parentInjector(hx::ObjectPtr<OBJ_>(this));
HXLINE( 321)		return injector;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Injector_obj,createChildInjector,return )

 ::minject::InjectionConfig Injector_obj::getAncestorMapping(hx::Class forClass,::String named){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_329_getAncestorMapping)
HXLINE( 330)		 ::minject::Injector parent = this->parentInjector;
HXLINE( 332)		while(hx::IsNotNull( parent )){
HXLINE( 334)			 ::minject::InjectionConfig parentConfig = parent->getConfigurationForRequest(forClass,named,false);
HXLINE( 336)			bool _hx_tmp;
HXDLIN( 336)			if (hx::IsNotNull( parentConfig )) {
HXLINE( 336)				_hx_tmp = parentConfig->hasOwnResponse();
            			}
            			else {
HXLINE( 336)				_hx_tmp = false;
            			}
HXDLIN( 336)			if (_hx_tmp) {
HXLINE( 338)				return parentConfig;
            			}
HXLINE( 341)			parent = parent->parentInjector;
            		}
HXLINE( 344)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Injector_obj,getAncestorMapping,return )

 ::minject::InjecteeDescription Injector_obj::getInjectionPoints(hx::Class forClass){
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_348_getInjectionPoints)
HXLINE( 349)		 ::Dynamic typeMeta = ::haxe::rtti::Meta_obj::getType(forClass);
HXLINE( 352)		bool _hx_tmp;
HXDLIN( 352)		if (hx::IsNotNull( typeMeta )) {
HXLINE( 352)			_hx_tmp = ::Reflect_obj::hasField(typeMeta,HX_("interface",b9,31,da,39));
            		}
            		else {
HXLINE( 352)			_hx_tmp = false;
            		}
HXDLIN( 352)		if (_hx_tmp) {
HXLINE( 353)			HX_STACK_DO_THROW(HX_("Interfaces can't be used as instantiatable classes.",34,59,41,1c));
            		}
HXLINE( 356)		 ::Dynamic fieldsMeta = this->getFields(forClass);
HXLINE( 358)		::Dynamic ctorInjectionPoint = null();
HXLINE( 359)		::Array< ::Dynamic> injectionPoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 360)		::cpp::VirtualArray postConstructMethodPoints = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 362)		{
HXLINE( 362)			int _g = 0;
HXDLIN( 362)			::Array< ::String > _g1 = ::Reflect_obj::fields(fieldsMeta);
HXDLIN( 362)			while((_g < _g1->length)){
HXLINE( 362)				::String field = _g1->__get(_g);
HXDLIN( 362)				_g = (_g + 1);
HXLINE( 364)				 ::Dynamic fieldMeta = ::Reflect_obj::field(fieldsMeta,field);
HXLINE( 367)				bool inject = ::Reflect_obj::hasField(fieldMeta,HX_("inject",91,4a,ea,97));
HXLINE( 368)				bool post = ::Reflect_obj::hasField(fieldMeta,HX_("post",60,84,5c,4a));
HXLINE( 369)				 ::Dynamic type = ::Reflect_obj::field(fieldMeta,HX_("type",ba,f2,08,4d));
HXLINE( 370)				 ::Dynamic args = ::Reflect_obj::field(fieldMeta,HX_("args",5d,8d,74,40));
HXLINE( 372)				if ((field == HX_("_",5f,00,00,00))) {
HXLINE( 374)					if (hx::IsGreater( args->__Field(HX_("length",e6,94,07,9f),hx::paccDynamic),0 )) {
HXLINE( 376)						ctorInjectionPoint =  ::minject::point::ConstructorInjectionPoint_obj::__alloc( HX_CTX ,( (::Array< ::Dynamic>)(fieldMeta->__Field(HX_("args",5d,8d,74,40),hx::paccDynamic)) ));
            					}
            				}
            				else {
HXLINE( 379)					if (::Reflect_obj::hasField(fieldMeta,HX_("args",5d,8d,74,40))) {
HXLINE( 381)						if (inject) {
HXLINE( 383)							 ::minject::point::MethodInjectionPoint point =  ::minject::point::MethodInjectionPoint_obj::__alloc( HX_CTX ,field,( (::Array< ::Dynamic>)(fieldMeta->__Field(HX_("args",5d,8d,74,40),hx::paccDynamic)) ));
HXLINE( 384)							injectionPoints->push(point);
            						}
            						else {
HXLINE( 386)							if (post) {
HXLINE( 388)								int order;
HXDLIN( 388)								if (hx::IsNull( fieldMeta->__Field(HX_("post",60,84,5c,4a),hx::paccDynamic) )) {
HXLINE( 388)									order = 0;
            								}
            								else {
HXLINE( 388)									order = ( (int)( ::Dynamic(fieldMeta->__Field(HX_("post",60,84,5c,4a),hx::paccDynamic))->__GetItem(0)) );
            								}
HXLINE( 389)								 ::minject::point::PostConstructInjectionPoint point1 =  ::minject::point::PostConstructInjectionPoint_obj::__alloc( HX_CTX ,field,order);
HXLINE( 390)								postConstructMethodPoints->push(point1);
            							}
            						}
            					}
            					else {
HXLINE( 393)						if (hx::IsNotNull( type )) {
HXLINE( 395)							::String name;
HXDLIN( 395)							if (hx::IsNull( fieldMeta->__Field(HX_("inject",91,4a,ea,97),hx::paccDynamic) )) {
HXLINE( 395)								name = null();
            							}
            							else {
HXLINE( 395)								name = ( (::String)( ::Dynamic(fieldMeta->__Field(HX_("inject",91,4a,ea,97),hx::paccDynamic))->__GetItem(0)) );
            							}
HXLINE( 396)							 ::minject::point::PropertyInjectionPoint point2 =  ::minject::point::PropertyInjectionPoint_obj::__alloc( HX_CTX ,field,( (::String)( ::Dynamic(fieldMeta->__Field(HX_("type",ba,f2,08,4d),hx::paccDynamic))->__GetItem(0)) ),name);
HXLINE( 397)							injectionPoints->push(point2);
            						}
            					}
            				}
            			}
            		}
HXLINE( 401)		if ((postConstructMethodPoints->get_length() > 0)) {
            			HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            			int _hx_run( ::Dynamic a, ::Dynamic b){
            				HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_403_getInjectionPoints)
HXLINE( 403)				return (a->__Field(HX_("order",8e,f0,20,35),hx::paccDynamic) - b->__Field(HX_("order",8e,f0,20,35),hx::paccDynamic));
            			}
            			HX_END_LOCAL_FUNC2(return)

HXLINE( 403)			postConstructMethodPoints->sort( ::Dynamic(new _hx_Closure_0()));
HXLINE( 404)			{
HXLINE( 404)				int _g2 = 0;
HXDLIN( 404)				while((_g2 < postConstructMethodPoints->get_length())){
HXLINE( 404)					 ::Dynamic point3 = postConstructMethodPoints->__get(_g2);
HXDLIN( 404)					_g2 = (_g2 + 1);
HXDLIN( 404)					injectionPoints->push(point3);
            				}
            			}
            		}
HXLINE( 407)		if (hx::IsNull( ctorInjectionPoint )) {
HXLINE( 408)			ctorInjectionPoint =  ::minject::point::NoParamsConstructorInjectionPoint_obj::__alloc( HX_CTX );
            		}
HXLINE( 410)		 ::minject::InjecteeDescription injecteeDescription =  ::minject::InjecteeDescription_obj::__alloc( HX_CTX ,ctorInjectionPoint,injectionPoints);
HXLINE( 411)		this->injecteeDescriptions->set(forClass,injecteeDescription);
HXLINE( 412)		return injecteeDescription;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,getInjectionPoints,return )

 ::minject::InjectionConfig Injector_obj::getConfigurationForRequest(hx::Class forClass,::String named, ::Dynamic __o_traverseAncestors){
 ::Dynamic traverseAncestors = __o_traverseAncestors.Default(true);
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_416_getConfigurationForRequest)
HXLINE( 417)		::String requestName = ((this->getClassName(forClass) + HX_("#",23,00,00,00)) + named);
HXLINE( 419)		if (!(this->injectionConfigs->exists(requestName))) {
HXLINE( 421)			bool _hx_tmp;
HXDLIN( 421)			bool _hx_tmp1;
HXDLIN( 421)			if (( (bool)(traverseAncestors) )) {
HXLINE( 421)				_hx_tmp1 = hx::IsNotNull( this->parentInjector );
            			}
            			else {
HXLINE( 421)				_hx_tmp1 = false;
            			}
HXDLIN( 421)			if (_hx_tmp1) {
HXLINE( 421)				_hx_tmp = this->parentInjector->hasMapping(forClass,named);
            			}
            			else {
HXLINE( 421)				_hx_tmp = false;
            			}
HXDLIN( 421)			if (_hx_tmp) {
HXLINE( 423)				return this->getAncestorMapping(forClass,named);
            			}
HXLINE( 424)			return null();
            		}
HXLINE( 427)		return ( ( ::minject::InjectionConfig)(this->injectionConfigs->get(requestName)) );
            	}


HX_DEFINE_DYNAMIC_FUNC3(Injector_obj,getConfigurationForRequest,return )

 ::minject::Injector Injector_obj::set_parentInjector( ::minject::Injector value){
            	HX_GC_STACKFRAME(&_hx_pos_738cdc6e32f3b607_431_set_parentInjector)
HXLINE( 433)		bool _hx_tmp;
HXDLIN( 433)		if (hx::IsNotNull( this->parentInjector )) {
HXLINE( 433)			_hx_tmp = hx::IsNull( value );
            		}
            		else {
HXLINE( 433)			_hx_tmp = false;
            		}
HXDLIN( 433)		if (_hx_tmp) {
HXLINE( 433)			this->attendedToInjectees =  ::minject::InjecteeSet_obj::__alloc( HX_CTX );
            		}
HXLINE( 435)		this->parentInjector = value;
HXLINE( 438)		if (hx::IsNotNull( this->parentInjector )) {
HXLINE( 438)			this->attendedToInjectees = this->parentInjector->attendedToInjectees;
            		}
HXLINE( 440)		return this->parentInjector;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,set_parentInjector,return )

::String Injector_obj::getClassName(hx::Class forClass){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_445_getClassName)
HXDLIN( 445)		if (hx::IsNull( forClass )) {
HXDLIN( 445)			return HX_("Dynamic",5f,c7,66,03);
            		}
            		else {
HXLINE( 446)			return ::Type_obj::getClassName(forClass);
            		}
HXLINE( 445)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,getClassName,return )

 ::Dynamic Injector_obj::getFields(hx::Class type){
            	HX_STACKFRAME(&_hx_pos_738cdc6e32f3b607_450_getFields)
HXLINE( 451)		 ::Dynamic meta =  ::Dynamic(hx::Anon_obj::Create(0));
HXLINE( 452)		while(hx::IsNotNull( type )){
HXLINE( 454)			 ::Dynamic typeMeta = ::haxe::rtti::Meta_obj::getFields(type);
HXLINE( 455)			{
HXLINE( 455)				int _g = 0;
HXDLIN( 455)				::Array< ::String > _g1 = ::Reflect_obj::fields(typeMeta);
HXDLIN( 455)				while((_g < _g1->length)){
HXLINE( 455)					::String field = _g1->__get(_g);
HXDLIN( 455)					_g = (_g + 1);
HXLINE( 456)					::Reflect_obj::setField(meta,field,::Reflect_obj::field(typeMeta,field));
            				}
            			}
HXLINE( 457)			type = ::Type_obj::getSuperClass(type);
            		}
HXLINE( 459)		return meta;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Injector_obj,getFields,return )


hx::ObjectPtr< Injector_obj > Injector_obj::__new() {
	hx::ObjectPtr< Injector_obj > __this = new Injector_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Injector_obj > Injector_obj::__alloc(hx::Ctx *_hx_ctx) {
	Injector_obj *__this = (Injector_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Injector_obj), true, "minject.Injector"));
	*(void **)__this = Injector_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Injector_obj::Injector_obj()
{
}

void Injector_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Injector);
	HX_MARK_MEMBER_NAME(attendedToInjectees,"attendedToInjectees");
	HX_MARK_MEMBER_NAME(parentInjector,"parentInjector");
	HX_MARK_MEMBER_NAME(injectionConfigs,"injectionConfigs");
	HX_MARK_MEMBER_NAME(injecteeDescriptions,"injecteeDescriptions");
	HX_MARK_END_CLASS();
}

void Injector_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(attendedToInjectees,"attendedToInjectees");
	HX_VISIT_MEMBER_NAME(parentInjector,"parentInjector");
	HX_VISIT_MEMBER_NAME(injectionConfigs,"injectionConfigs");
	HX_VISIT_MEMBER_NAME(injecteeDescriptions,"injecteeDescriptions");
}

hx::Val Injector_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"unmap") ) { return hx::Val( unmap_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"mapValue") ) { return hx::Val( mapValue_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"construct") ) { return hx::Val( construct_dyn() ); }
		if (HX_FIELD_EQ(inName,"getFields") ) { return hx::Val( getFields_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getMapping") ) { return hx::Val( getMapping_dyn() ); }
		if (HX_FIELD_EQ(inName,"injectInto") ) { return hx::Val( injectInto_dyn() ); }
		if (HX_FIELD_EQ(inName,"hasMapping") ) { return hx::Val( hasMapping_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"instantiate") ) { return hx::Val( instantiate_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getClassName") ) { return hx::Val( getClassName_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"parentInjector") ) { return hx::Val( parentInjector ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"injectionConfigs") ) { return hx::Val( injectionConfigs ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getAncestorMapping") ) { return hx::Val( getAncestorMapping_dyn() ); }
		if (HX_FIELD_EQ(inName,"getInjectionPoints") ) { return hx::Val( getInjectionPoints_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_parentInjector") ) { return hx::Val( set_parentInjector_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"attendedToInjectees") ) { return hx::Val( attendedToInjectees ); }
		if (HX_FIELD_EQ(inName,"createChildInjector") ) { return hx::Val( createChildInjector_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"injecteeDescriptions") ) { return hx::Val( injecteeDescriptions ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"getConfigurationForRequest") ) { return hx::Val( getConfigurationForRequest_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Injector_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"parentInjector") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_parentInjector(inValue.Cast<  ::minject::Injector >()) );parentInjector=inValue.Cast<  ::minject::Injector >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"injectionConfigs") ) { injectionConfigs=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"attendedToInjectees") ) { attendedToInjectees=inValue.Cast<  ::minject::InjecteeSet >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"injecteeDescriptions") ) { injecteeDescriptions=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Injector_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("attendedToInjectees",6e,c4,a0,ba));
	outFields->push(HX_("parentInjector",3e,2d,d7,e6));
	outFields->push(HX_("injectionConfigs",5a,00,d5,6f));
	outFields->push(HX_("injecteeDescriptions",c8,ce,cd,f1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Injector_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::minject::InjecteeSet*/ ,(int)offsetof(Injector_obj,attendedToInjectees),HX_("attendedToInjectees",6e,c4,a0,ba)},
	{hx::fsObject /*::minject::Injector*/ ,(int)offsetof(Injector_obj,parentInjector),HX_("parentInjector",3e,2d,d7,e6)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Injector_obj,injectionConfigs),HX_("injectionConfigs",5a,00,d5,6f)},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(Injector_obj,injecteeDescriptions),HX_("injecteeDescriptions",c8,ce,cd,f1)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Injector_obj_sStaticStorageInfo = 0;
#endif

static ::String Injector_obj_sMemberFields[] = {
	HX_("attendedToInjectees",6e,c4,a0,ba),
	HX_("parentInjector",3e,2d,d7,e6),
	HX_("injectionConfigs",5a,00,d5,6f),
	HX_("injecteeDescriptions",c8,ce,cd,f1),
	HX_("mapValue",35,ef,fa,a8),
	HX_("getMapping",18,01,dc,93),
	HX_("injectInto",d1,d7,85,29),
	HX_("construct",17,58,ad,4f),
	HX_("instantiate",aa,c2,97,f5),
	HX_("unmap",e3,61,ea,a6),
	HX_("hasMapping",d4,62,2e,cf),
	HX_("createChildInjector",14,cf,2e,e9),
	HX_("getAncestorMapping",05,3f,25,bd),
	HX_("getInjectionPoints",64,15,4f,9a),
	HX_("getConfigurationForRequest",a6,81,5a,b6),
	HX_("set_parentInjector",7b,40,20,5f),
	HX_("getClassName",2d,2f,94,eb),
	HX_("getFields",af,17,e5,fc),
	::String(null()) };

hx::Class Injector_obj::__mClass;

void Injector_obj::__register()
{
	Injector_obj _hx_dummy;
	Injector_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("minject.Injector",c4,a9,3d,3b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Injector_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Injector_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Injector_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Injector_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace minject
