// Generated by Haxe 4.0.0-preview.4+1e3e5e0
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_minject_InjecteeSet
#include <minject/InjecteeSet.h>
#endif
#ifndef INCLUDED_minject_Injector
#include <minject/Injector.h>
#endif
#ifndef INCLUDED_mmvc_api_ICommand
#include <mmvc/api/ICommand.h>
#endif
#ifndef INCLUDED_mmvc_api_ICommandMap
#include <mmvc/api/ICommandMap.h>
#endif
#ifndef INCLUDED_mmvc_base_CommandMap
#include <mmvc/base/CommandMap.h>
#endif
#ifndef INCLUDED_msignal_Signal
#include <msignal/Signal.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_39_new,"mmvc.base.CommandMap","new",0xe57bf2ff,"mmvc.base.CommandMap.new","mmvc/base/CommandMap.hx",39,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_48_mapSignalClass,"mmvc.base.CommandMap","mapSignalClass",0x98f14f35,"mmvc.base.CommandMap.mapSignalClass","mmvc/base/CommandMap.hx",48,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_73_mapSignal,"mmvc.base.CommandMap","mapSignal",0x7827ee03,"mmvc.base.CommandMap.mapSignal","mmvc/base/CommandMap.hx",73,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_55_mapSignal,"mmvc.base.CommandMap","mapSignal",0x7827ee03,"mmvc.base.CommandMap.mapSignal","mmvc/base/CommandMap.hx",55,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_81_unmapSignalClass,"mmvc.base.CommandMap","unmapSignalClass",0xf857f18e,"mmvc.base.CommandMap.unmapSignalClass","mmvc/base/CommandMap.hx",81,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_92_unmapSignal,"mmvc.base.CommandMap","unmapSignal",0x7e166a4a,"mmvc.base.CommandMap.unmapSignal","mmvc/base/CommandMap.hx",92,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_105_getSignalClassInstance,"mmvc.base.CommandMap","getSignalClassInstance",0x97505630,"mmvc.base.CommandMap.getSignalClassInstance","mmvc/base/CommandMap.hx",105,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_115_createSignalClassInstance,"mmvc.base.CommandMap","createSignalClassInstance",0x22b5bca8,"mmvc.base.CommandMap.createSignalClassInstance","mmvc/base/CommandMap.hx",115,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_131_hasCommand,"mmvc.base.CommandMap","hasCommand",0xd5765852,"mmvc.base.CommandMap.hasCommand","mmvc/base/CommandMap.hx",131,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_141_hasSignalCommand,"mmvc.base.CommandMap","hasSignalCommand",0x2f3eee0a,"mmvc.base.CommandMap.hasSignalCommand","mmvc/base/CommandMap.hx",141,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_150_routeSignalToCommand,"mmvc.base.CommandMap","routeSignalToCommand",0x5b2cf480,"mmvc.base.CommandMap.routeSignalToCommand","mmvc/base/CommandMap.hx",150,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_168_createCommandInstance,"mmvc.base.CommandMap","createCommandInstance",0x063322c3,"mmvc.base.CommandMap.createCommandInstance","mmvc/base/CommandMap.hx",168,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_173_mapSignalValues,"mmvc.base.CommandMap","mapSignalValues",0x84da4a45,"mmvc.base.CommandMap.mapSignalValues","mmvc/base/CommandMap.hx",173,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_181_unmapSignalValues,"mmvc.base.CommandMap","unmapSignalValues",0x9f41b5cc,"mmvc.base.CommandMap.unmapSignalValues","mmvc/base/CommandMap.hx",181,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_189_detain,"mmvc.base.CommandMap","detain",0x16516d54,"mmvc.base.CommandMap.detain","mmvc/base/CommandMap.hx",189,0xed7e18f1)
HX_LOCAL_STACK_FRAME(_hx_pos_ea49f0d42676f9f1_194_release,"mmvc.base.CommandMap","release",0x1e84e3e6,"mmvc.base.CommandMap.release","mmvc/base/CommandMap.hx",194,0xed7e18f1)
namespace mmvc{
namespace base{

void CommandMap_obj::__construct( ::minject::Injector injector){
            	HX_GC_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_39_new)
HXLINE(  40)		this->injector = injector;
HXLINE(  42)		this->signalMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE(  43)		this->signalClassMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE(  44)		this->detainedCommands =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            	}

Dynamic CommandMap_obj::__CreateEmpty() { return new CommandMap_obj; }

void *CommandMap_obj::_hx_vtable = 0;

Dynamic CommandMap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< CommandMap_obj > _hx_result = new CommandMap_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool CommandMap_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x364b0f0f;
}

static ::mmvc::api::ICommandMap_obj _hx_mmvc_base_CommandMap__hx_mmvc_api_ICommandMap= {
	( void (hx::Object::*)( ::msignal::Signal,hx::Class, ::Dynamic))&::mmvc::base::CommandMap_obj::mapSignal,
	(  ::msignal::Signal (hx::Object::*)(hx::Class,hx::Class, ::Dynamic))&::mmvc::base::CommandMap_obj::mapSignalClass,
	( bool (hx::Object::*)( ::msignal::Signal,hx::Class))&::mmvc::base::CommandMap_obj::hasSignalCommand,
	( void (hx::Object::*)( ::msignal::Signal,hx::Class))&::mmvc::base::CommandMap_obj::unmapSignal,
	( void (hx::Object::*)(hx::Class,hx::Class))&::mmvc::base::CommandMap_obj::unmapSignalClass,
	( void (hx::Object::*)(::Dynamic))&::mmvc::base::CommandMap_obj::detain,
	( void (hx::Object::*)(::Dynamic))&::mmvc::base::CommandMap_obj::release,
};

void *CommandMap_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x64c734ad: return &_hx_mmvc_base_CommandMap__hx_mmvc_api_ICommandMap;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

 ::msignal::Signal CommandMap_obj::mapSignalClass(hx::Class signalClass,hx::Class commandClass, ::Dynamic __o_oneShot){
 ::Dynamic oneShot = __o_oneShot.Default(false);
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_48_mapSignalClass)
HXLINE(  49)		 ::msignal::Signal signal = this->getSignalClassInstance(signalClass);
HXLINE(  50)		this->mapSignal(signal,commandClass,oneShot);
HXLINE(  51)		return signal;
            	}


HX_DEFINE_DYNAMIC_FUNC3(CommandMap_obj,mapSignalClass,return )

void CommandMap_obj::mapSignal( ::msignal::Signal signal,hx::Class commandClass, ::Dynamic __o_oneShot){
            		HX_BEGIN_LOCAL_FUNC_S4(hx::LocalFunc,_hx_Closure_0,hx::Class,commandClass, ::mmvc::base::CommandMap,me, ::Dynamic,oneShot, ::msignal::Signal,signal) HXARGC(1)
            		void _hx_run(::cpp::VirtualArray args){
            			HX_GC_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_73_mapSignal)
HXLINE(  73)			me->routeSignalToCommand(signal,args,commandClass,( (bool)(oneShot) ));
            		}
            		HX_END_LOCAL_FUNC1((void))

 ::Dynamic oneShot = __o_oneShot.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_55_mapSignal)
HXLINE(  56)		if (this->hasSignalCommand(signal,commandClass)) {
HXLINE(  56)			return;
            		}
HXLINE(  58)		 ::haxe::ds::ObjectMap signalCommandMap;
HXLINE(  60)		if (this->signalMap->exists(signal)) {
HXLINE(  62)			signalCommandMap = ( ( ::haxe::ds::ObjectMap)(this->signalMap->get(signal)) );
            		}
            		else {
HXLINE(  66)			signalCommandMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE(  67)			this->signalMap->set(signal,signalCommandMap);
            		}
HXLINE(  70)		 ::mmvc::base::CommandMap me = hx::ObjectPtr<OBJ_>(this);
HXLINE(  71)		 ::Dynamic callbackFunction = ::Reflect_obj::makeVarArgs( ::Dynamic(new _hx_Closure_0(commandClass,me,oneShot,signal)));
HXLINE(  76)		signalCommandMap->set(commandClass,callbackFunction);
HXLINE(  77)		signal->add(callbackFunction);
            	}


HX_DEFINE_DYNAMIC_FUNC3(CommandMap_obj,mapSignal,(void))

void CommandMap_obj::unmapSignalClass(hx::Class signalClass,hx::Class commandClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_81_unmapSignalClass)
HXLINE(  82)		 ::msignal::Signal signal = this->getSignalClassInstance(signalClass);
HXLINE(  83)		this->unmapSignal(signal,commandClass);
HXLINE(  84)		if (!(this->hasCommand(signal))) {
HXLINE(  86)			this->injector->unmap(signalClass,null());
HXLINE(  87)			this->signalClassMap->remove(signalClass);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(CommandMap_obj,unmapSignalClass,(void))

void CommandMap_obj::unmapSignal( ::msignal::Signal signal,hx::Class commandClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_92_unmapSignal)
HXLINE(  93)		 ::haxe::ds::ObjectMap callbacksByCommandClass = ( ( ::haxe::ds::ObjectMap)(this->signalMap->get(signal)) );
HXLINE(  94)		if (hx::IsNull( callbacksByCommandClass )) {
HXLINE(  94)			return;
            		}
HXLINE(  96)		 ::Dynamic callbackFunction = callbacksByCommandClass->get(commandClass);
HXLINE(  97)		if (hx::IsNull( callbackFunction )) {
HXLINE(  97)			return;
            		}
HXLINE(  99)		if (!(this->hasCommand(signal))) {
HXLINE(  99)			this->signalMap->remove(signal);
            		}
HXLINE( 100)		signal->remove(callbackFunction);
HXLINE( 101)		callbacksByCommandClass->remove(commandClass);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CommandMap_obj,unmapSignal,(void))

 ::msignal::Signal CommandMap_obj::getSignalClassInstance(hx::Class signalClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_105_getSignalClassInstance)
HXLINE( 106)		if (this->signalClassMap->exists(signalClass)) {
HXLINE( 108)			return ( ( ::msignal::Signal)(this->signalClassMap->get(signalClass)) );
            		}
HXLINE( 111)		return this->createSignalClassInstance(signalClass);
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,getSignalClassInstance,return )

 ::msignal::Signal CommandMap_obj::createSignalClassInstance(hx::Class signalClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_115_createSignalClassInstance)
HXLINE( 116)		 ::minject::Injector injectorForSignalInstance = this->injector;
HXLINE( 118)		if (this->injector->hasMapping(hx::ClassOf< ::minject::Injector >(),null())) {
HXLINE( 120)			injectorForSignalInstance = this->injector->getInstance(hx::ClassOf< ::minject::Injector >(),null()).StaticCast<  ::minject::Injector >();
            		}
HXLINE( 123)		 ::msignal::Signal signal = injectorForSignalInstance->instantiate(signalClass).StaticCast<  ::msignal::Signal >();
HXLINE( 124)		injectorForSignalInstance->mapValue(signalClass,signal,null());
HXLINE( 125)		this->signalClassMap->set(signalClass,signal);
HXLINE( 127)		return signal;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,createSignalClassInstance,return )

bool CommandMap_obj::hasCommand( ::msignal::Signal signal){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_131_hasCommand)
HXLINE( 132)		 ::haxe::ds::ObjectMap callbacksByCommandClass = ( ( ::haxe::ds::ObjectMap)(this->signalMap->get(signal)) );
HXLINE( 133)		if (hx::IsNull( callbacksByCommandClass )) {
HXLINE( 133)			return false;
            		}
HXLINE( 135)		int count = 0;
HXLINE( 136)		{
HXLINE( 136)			 ::Dynamic key = callbacksByCommandClass->iterator();
HXDLIN( 136)			while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 136)				 ::Dynamic key1 = key->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)();
HXDLIN( 136)				count = (count + 1);
            			}
            		}
HXLINE( 137)		return (count > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,hasCommand,return )

bool CommandMap_obj::hasSignalCommand( ::msignal::Signal signal,hx::Class commandClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_141_hasSignalCommand)
HXLINE( 142)		 ::haxe::ds::ObjectMap callbacksByCommandClass = ( ( ::haxe::ds::ObjectMap)(this->signalMap->get(signal)) );
HXLINE( 143)		if (hx::IsNull( callbacksByCommandClass )) {
HXLINE( 143)			return false;
            		}
HXLINE( 145)		 ::Dynamic callbackFunction = callbacksByCommandClass->get(commandClass);
HXLINE( 146)		return hx::IsNotNull( callbackFunction );
            	}


HX_DEFINE_DYNAMIC_FUNC2(CommandMap_obj,hasSignalCommand,return )

void CommandMap_obj::routeSignalToCommand( ::msignal::Signal signal,::cpp::VirtualArray valueObjects,hx::Class commandClass,bool oneshot){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_150_routeSignalToCommand)
HXLINE( 151)		this->injector->mapValue(hx::ClassOf< ::msignal::Signal >(),signal,null());
HXLINE( 153)		this->mapSignalValues(signal->valueClasses,valueObjects);
HXLINE( 154)		::Dynamic command = this->createCommandInstance(commandClass);
HXLINE( 155)		this->injector->unmap(hx::ClassOf< ::msignal::Signal >(),null());
HXLINE( 156)		this->unmapSignalValues(signal->valueClasses,valueObjects);
HXLINE( 157)		::mmvc::api::ICommand_obj::execute(command);
HXLINE( 158)		this->injector->attendedToInjectees->remove(command);
HXLINE( 160)		if (oneshot) {
HXLINE( 162)			this->unmapSignal(signal,commandClass);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(CommandMap_obj,routeSignalToCommand,(void))

::Dynamic CommandMap_obj::createCommandInstance(hx::Class commandClass){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_168_createCommandInstance)
HXDLIN( 168)		return this->injector->instantiate(commandClass);
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,createCommandInstance,return )

void CommandMap_obj::mapSignalValues(::cpp::VirtualArray valueClasses,::cpp::VirtualArray valueObjects){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_173_mapSignalValues)
HXDLIN( 173)		int _g1 = 0;
HXDLIN( 173)		int _g = valueClasses->get_length();
HXDLIN( 173)		while((_g1 < _g)){
HXDLIN( 173)			_g1 = (_g1 + 1);
HXDLIN( 173)			int i = (_g1 - 1);
HXLINE( 175)			 ::minject::Injector _hx_tmp = this->injector;
HXDLIN( 175)			_hx_tmp->mapValue(valueClasses->__get(i),valueObjects->__get(i),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(CommandMap_obj,mapSignalValues,(void))

void CommandMap_obj::unmapSignalValues(::cpp::VirtualArray valueClasses,::cpp::VirtualArray valueObjects){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_181_unmapSignalValues)
HXDLIN( 181)		int _g1 = 0;
HXDLIN( 181)		int _g = valueClasses->get_length();
HXDLIN( 181)		while((_g1 < _g)){
HXDLIN( 181)			_g1 = (_g1 + 1);
HXDLIN( 181)			int i = (_g1 - 1);
HXLINE( 183)			 ::minject::Injector _hx_tmp = this->injector;
HXDLIN( 183)			_hx_tmp->unmap(valueClasses->__get(i),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(CommandMap_obj,unmapSignalValues,(void))

void CommandMap_obj::detain(::Dynamic command){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_189_detain)
HXDLIN( 189)		this->detainedCommands->set(command,true);
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,detain,(void))

void CommandMap_obj::release(::Dynamic command){
            	HX_STACKFRAME(&_hx_pos_ea49f0d42676f9f1_194_release)
HXDLIN( 194)		if (this->detainedCommands->exists(command)) {
HXLINE( 196)			this->detainedCommands->remove(command);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(CommandMap_obj,release,(void))


hx::ObjectPtr< CommandMap_obj > CommandMap_obj::__new( ::minject::Injector injector) {
	hx::ObjectPtr< CommandMap_obj > __this = new CommandMap_obj();
	__this->__construct(injector);
	return __this;
}

hx::ObjectPtr< CommandMap_obj > CommandMap_obj::__alloc(hx::Ctx *_hx_ctx, ::minject::Injector injector) {
	CommandMap_obj *__this = (CommandMap_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(CommandMap_obj), true, "mmvc.base.CommandMap"));
	*(void **)__this = CommandMap_obj::_hx_vtable;
	__this->__construct(injector);
	return __this;
}

CommandMap_obj::CommandMap_obj()
{
}

void CommandMap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(CommandMap);
	HX_MARK_MEMBER_NAME(injector,"injector");
	HX_MARK_MEMBER_NAME(signalMap,"signalMap");
	HX_MARK_MEMBER_NAME(signalClassMap,"signalClassMap");
	HX_MARK_MEMBER_NAME(detainedCommands,"detainedCommands");
	HX_MARK_END_CLASS();
}

void CommandMap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(injector,"injector");
	HX_VISIT_MEMBER_NAME(signalMap,"signalMap");
	HX_VISIT_MEMBER_NAME(signalClassMap,"signalClassMap");
	HX_VISIT_MEMBER_NAME(detainedCommands,"detainedCommands");
}

hx::Val CommandMap_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"detain") ) { return hx::Val( detain_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"release") ) { return hx::Val( release_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"injector") ) { return hx::Val( injector ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"signalMap") ) { return hx::Val( signalMap ); }
		if (HX_FIELD_EQ(inName,"mapSignal") ) { return hx::Val( mapSignal_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hasCommand") ) { return hx::Val( hasCommand_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"unmapSignal") ) { return hx::Val( unmapSignal_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"signalClassMap") ) { return hx::Val( signalClassMap ); }
		if (HX_FIELD_EQ(inName,"mapSignalClass") ) { return hx::Val( mapSignalClass_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"mapSignalValues") ) { return hx::Val( mapSignalValues_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"detainedCommands") ) { return hx::Val( detainedCommands ); }
		if (HX_FIELD_EQ(inName,"unmapSignalClass") ) { return hx::Val( unmapSignalClass_dyn() ); }
		if (HX_FIELD_EQ(inName,"hasSignalCommand") ) { return hx::Val( hasSignalCommand_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"unmapSignalValues") ) { return hx::Val( unmapSignalValues_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"routeSignalToCommand") ) { return hx::Val( routeSignalToCommand_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"createCommandInstance") ) { return hx::Val( createCommandInstance_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"getSignalClassInstance") ) { return hx::Val( getSignalClassInstance_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"createSignalClassInstance") ) { return hx::Val( createSignalClassInstance_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val CommandMap_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"injector") ) { injector=inValue.Cast<  ::minject::Injector >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"signalMap") ) { signalMap=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"signalClassMap") ) { signalClassMap=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"detainedCommands") ) { detainedCommands=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CommandMap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("injector",f4,31,ff,1e));
	outFields->push(HX_("signalMap",14,85,03,10));
	outFields->push(HX_("signalClassMap",cc,cf,a9,8c));
	outFields->push(HX_("detainedCommands",9a,34,5b,6d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo CommandMap_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::minject::Injector*/ ,(int)offsetof(CommandMap_obj,injector),HX_("injector",f4,31,ff,1e)},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(CommandMap_obj,signalMap),HX_("signalMap",14,85,03,10)},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(CommandMap_obj,signalClassMap),HX_("signalClassMap",cc,cf,a9,8c)},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(CommandMap_obj,detainedCommands),HX_("detainedCommands",9a,34,5b,6d)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *CommandMap_obj_sStaticStorageInfo = 0;
#endif

static ::String CommandMap_obj_sMemberFields[] = {
	HX_("injector",f4,31,ff,1e),
	HX_("signalMap",14,85,03,10),
	HX_("signalClassMap",cc,cf,a9,8c),
	HX_("detainedCommands",9a,34,5b,6d),
	HX_("mapSignalClass",74,1b,a5,fa),
	HX_("mapSignal",24,8a,65,97),
	HX_("unmapSignalClass",8d,8b,c6,07),
	HX_("unmapSignal",ab,10,0c,1d),
	HX_("getSignalClassInstance",6f,f9,18,ad),
	HX_("createSignalClassInstance",c9,6a,59,c1),
	HX_("hasCommand",11,59,21,0c),
	HX_("hasSignalCommand",09,88,ad,3e),
	HX_("routeSignalToCommand",ff,f9,89,db),
	HX_("createCommandInstance",64,ec,3a,d7),
	HX_("mapSignalValues",26,35,79,a0),
	HX_("unmapSignalValues",ed,da,99,10),
	HX_("detain",93,62,1f,70),
	HX_("release",c7,85,ed,58),
	::String(null()) };

hx::Class CommandMap_obj::__mClass;

void CommandMap_obj::__register()
{
	CommandMap_obj _hx_dummy;
	CommandMap_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("mmvc.base.CommandMap",8d,07,b1,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(CommandMap_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< CommandMap_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CommandMap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CommandMap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace mmvc
} // end namespace base
